[node学习文章](https://github.com/chyingp/nodejs-learning-guide)
# Node 高并发的原理
**Node的特点：事件驱动、非阻塞I/O、高并发**
Nodejs之所以单线程可以处理高并发的原因，得益于内部的事件循环机制和底层线程池实现。
遇到异步任务，node将所有的阻塞操作都交给了内部的线程池去实现。本质上的异步操作还是由线程池完成的，主线程本身只负责不断的往返调度，从而实现异步非阻塞I/O，这便是node单线程和事件驱动的精髓之处。

1）每个Node进程只有一个主线程在执行程序代码
2）当用户的网络请求、数据库操作、读取文件等其它的异步操作时，node都会把它放到Event Queue（"事件队列"）之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕
3）主线程代码执行完毕完成后，然后通过事件循环机制，依次取出对应的事件，从线程池中分配一个对应的线程去执行，当有事件执行完毕后，会通知主线程，主线程执行回调拿到对应的结果

# 如何做到接口防刷
因为之前做的是抽奖系统，接口防刷是非常必要的，也是高并发下的经典场景
其中的一些知识点，已经超过了前端的范畴，不过技不压身，多了解一些总是没错的

1）第一步：负载均衡层的限流，防止用户重复抽奖
在负载均衡设备中做一些配置，判断如果同一个用户在1分钟之内多次发送请求来进行抽奖，就认为是恶意重复抽奖，或者是他们自己写的脚本在刷，这种流量一律认为是无效流量，在负载均衡设备那个层次就给直接屏蔽掉。所以这里就可以把无效流量给拦截掉

2）第二步：暴力拦截流量
其实秒杀、抢红包、抽奖，这类系统有一个共同的特点，那就是假设有50万请求涌入进来，可能前5万请求就直接把事儿干完了，甚至是前500请求就把事儿干完了,后续的几十万流量是无效的，不需要让他们进入后台系统执行业务逻辑了,这样的话，其实在负载均衡这一层（可以考虑用Nginx之类的来实现）就可以拦截掉99%的无效流量。

3）第三步：ip或用户抽奖次数校验

建立一个抽奖表，该表记录所有参与抽奖的ip和用户信息，比如判断5s内，该用户连续抽奖了2次以上，就拒绝该请求，认为是在刷接口，就把该用户和ip加入黑名单

# mongoDb 和 mySQL 的区别
1）mongoDb 是非关系型数据库，mySQL是关系型数据库
mongoDb里存储的是json格式的数据，键值对形式，该数据结构非常符合前端的需求。关系型数据天然就是表格式的，就是后端常说的“表”，数据存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。mongodb所负责部分以文档形式存储，能够有较好的代码亲和性，json格式的直接写入方便。(如日志之类，事件的记录，内容管理或者博客平台等等。) 
2）对事务性的支持不同
mongoDb不支持事务，mySQL支持事务。事务的好处便于回滚，如第一个账户划出款项必须保证正确的存入第二个账户，如果第二个环节没有完成，整个的过程都应该取消，否则就会发生丢失款项的问题。这时就需要回滚，恢复到初始的状态。

# 高并发时的如何正确修改库存

抽奖或秒杀活动，同时一千个请求过来，但奖品库存只有一个，期望的结果是只有一个人中奖，剩余999个人没有中奖
但压测时，遇到的情况却是1000个都中奖了，并且库存还是一个，原因就是高并发时，一千个请求同时读到的库存都是一个，都中奖后，库存同时减一，最后导致库存没有减对。解决此类问题，就是要给数据库加锁的概念，保证库存一个一个减、串行的减，解决方式是使用mongoDb中update方法减库存。mysql是本来就有对同一行操作有锁的概念，为了减轻mysql锁的问题可以实现主从线程来减轻压力。

# Redis
由c语言编写，可基于内存亦可持久化的日志型、Key-Value数据库，它通常被称为数据结构服务器，因为值可以是set、zset、list、hash、string这五种类型。

Redis的特点
1）Redis也是一种数据库，Redis中的数据是放到内存中的，Redis查询速度极快。一些常用的数据，可以存到Redis中，缩短从数据库查询数据的时间
2）Redis可以设置过期时间，可以将一些需要定期过期的信息放到Redis中，有点类似cookie

运用场景
1）将经常查询的信息存储到redis中，如抽奖活动的配置信息，这些信息查询的频率最高，放到Redis中可以提高查询速度，还可以存储用户的个人信息（权限、基础信息等）
2）需要设置过期时长的信息，比如微信授权，每2小时去过期一次，将对应的授权code存进去，到时删除

## 优点
1、支持多种数据类型
在做好友系统，查看自己的好友关系。redis相对简单，直接支持list的存储。直接提取出所有好友列表信息

2、持久化存储
作为一个内存数据库，最担心的，就是万一机器死机宕机，数据就会消失掉。redis会对数据做持久化存储。

3、性能很好
由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。

## 缺点
1、由于是内存数据库，所以单台机器存储的数据量跟机器本身的内存大小有关。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。定时删除和定期删除为主动删除，Redis会定期主动淘汰一批已过去的key。惰性删除为被动删除，用到的时候才会去检验key是不是已过期，过期就删除过期的key。惰性删除是redis服务器内置策略。

2、如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本以后，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的从库。

3、修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务。


# node创建子进程
```
// 具体代码
// parent.js
const cp = require("child_process");
// 通过child_process中的fork方法来生成子进程
let child = cp.fork("child.js"); 
child.send({ message: "from_parent" }); // send方法发送数据
child.on("message", res => console.log(res)); // on方法接收数据
// child.js
process.on("message", res => console.log(res));
process.send({ message: "from_child" });
```
## Node的cluster

Node主线程是单线程的，应用程序运行于单个进程中，如果使用node index.js方式运行，就启动了一个进程，只能在一个CPU中进行运算，无法充分利用服务器的多核CPU。因此，需要多进程分发策略，即**主进程接收所有请求，然后通过一定的负载均衡策略分发到不同的 Node.js 子进程中**。Node的 cluster 模块，不仅提供了开箱即用的能力去使用服务器的多核CPU，而且还提供一个零停机时间重新启动整个应用程序能力，提高Node进程的可用性。Cluster会创建一个master，然后根据你指定的数量复制出多个server app（也被称之为工作线程）。它通过IPC通道与工作线程之间进行通信，并使用内置的负载均衡来更好地处理线程之间的压力，该负载均衡使用了Round-robin算法（也被称之为循环算法）。

cluster 模块基于child_process模块的fork方法，多次fork主进程，产生多个子进程，这样就可以使用多核CPU，充分利用了服务器的资源。这种方式 **主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程，支持负载均衡。**PM2进程管理工具会将这个过程变得更容易执行。在 cluster 模式中存在 master 和 worker 的概念，master 就是主进程，worker 则是子进程。master会通过fork产生多个worker，并管理他们。每一个worker代表着一个应用程序的实例。**master会接收所有的请求，并通过负载均衡算法(round-robin)分发给子进程。**Linux服务器默认会开启这个功能，并且可以全局修改以让操作系统本身支持负载均衡。
```
var cluster = require('cluster');  
var http    = require('http');  
var os      = require('os');

var numCPUs = os.cpus().length;

if (cluster.isMaster) {  
  // Master:
  // Let's fork as many workers as you have CPU cores

  for (var i = 0; i < numCPUs; ++i) {
    cluster.fork();
  }
} else {
  // Worker:
  // Let's spawn a HTTP server
  // (Workers can share any TCP connection.
  //  In this case its a HTTP server)

  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end("hello world");
  }).listen(8080);
}
```

共享状态和负载均衡粘性分配。例如：采用集群的方式，我们不能将数据放到内存当中，因为每个worker进程都独有自己的内存空间。假如我们将数据缓存在一个woker进程中，其他woker进程无法访问到。假如我们想要在集群模式下缓存数据，我们就需要使用想Redis这样的工具。
验证用户。对于集群，身份验证请求通过master进程发送给一个worker进程。该worker进程将开始识别该用户的状态。但是，当同一个用户发出另一个请求时，负载均衡可能会将它们发送给其他没有经过身份验证的工作人员。在一个实例内存中保留对该用户身份验证的会话将不再起作用。这个问题可以通过多种方式解决。**通过将这些会话的信息存储在共享数据库或 Redis 节点中，这样多个woker进程之间可以共享状态。**但是，应用此策略需要更改一些代码，这并不是唯一的解决方法。还有另一中侵入性更小的方式—负载均衡粘性分配。因为负载均衡工具都支持此方式，实现起来也比较容易。**当用户通过woker的身份验证时，我们在负载均衡器处保留这个关系的记录，形成一张映射表。**当接到同一用户请求，在映射表中进行查找，**找到之前的会话在哪个woker进程中，然后再次分配到该woker进程中**。
## PM2原理

[pm2的实现原理](https://quincychen.cn/pm2-implementation/)
[pm2实现原理2](https://lagou.feishu.cn/docs/doccnyq5KSbMLfuu9y4bJVMKCKb#)

主要作用：

1）内建负载均衡（使用Node cluster集群模块）
2）线程守护，keep alive
3）0秒停机重载，维护升级的时候不需要停机
4）停止不稳定的进程（避免无限循环）
```
pm2 基于 cluster模块 进行了封装，它能自动监控进程状态、重启进程、停止不稳定进程、日志存储等。利用 pm2 时，可以在不修改代码的情况下实现负载均衡集群。

这篇文章我们要关注的是 pm2 的 Satan进程、God守护进程 以及 两者之间的 进程间远程调用RPC。其中 Satan.js 提供程序的退出、杀死等方法，God.js 负责维持进程的正常运行，God进程启动后一直运行，相当于 cluster 中的 Master进程，维持 worker 进程的正常运行。pm2 的执行流程，每次命令行输入时都会执行一次 Satan 程序，然后判断 God 进程是否正在运行，确保 God 进程正常运行后， Satan 会通过 RPC 调用 God 中对应的方法启动服务。

PM2的reload <app name>功能将依次重启所有的工作线程。每一个线程会等待在新的线程创建之后才会被终止掉，因此，当你在产品环境部署新的代码时，server会不间断地一直保持运行。

　　使用gracefulReload功能可以达到相同的目的，不同的是它不会立即终止工作线程，而是通过IPC发送一个shutdown信号来关闭所有当前的连接并处理一些自定义的任务，然后再优雅地退出。如下面的代码：
```




