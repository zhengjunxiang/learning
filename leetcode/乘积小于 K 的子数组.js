// 给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。

// 示例 1:
// 输入: nums = [10,5,2,6], k = 100 输出: 8 
// 解释: 8 个乘积小于 100 的子数组分别为: 
// [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。 
// 需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 
// 示例 2:
// 输入: nums = [1,2,3], k = 0 输出: 0

// 提示: 
// ● 1 <= nums.length <= 3 * 104
// ● 1 <= nums[i] <= 1000
// ● 0 <= k <= 106

// 用指针P1和P2指向数组中的两个数字，两个指针之间的数字组成一个子数组。
// 指针P1永远不会走到指针P2的右边。两个指针初始化都指向数组的第1个数字（下标为0的数字）。

// 如果两个指针之间的子数组中数字的乘积大于或等于k，则向右移动指针P1。
// 向右移动指针P1相当于从子数组中删除最左边的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变小。

// 目标是求出所有数字乘积小于k的子数组的个数，一旦向右移动指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。
// 这是因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。
// 此时两个指针之间有多少个数字，就有几个子数组。将数字累加就是最终结果。

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var numSubarrayProductLessThanK = function(nums, k) {
    let len = nums.length;
    let res = 0;
    let product = 1;
    let P1 = 0;
    for (let P2 = 0; P2 < len; P2++) {
        product *= nums[P2];
        while (P1 <= P2 && product >=k ) {
            product /= nums[P1];
            P1++;
        }
        res += P2 - P1 + 1;
    }
    return res;
};