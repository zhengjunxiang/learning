[原文链接](https://mp.weixin.qq.com/s/uxSoXkmi5KIGNPsyd5cXrA)

# 内存的重要性
随着web的发展与普及，前端页面不仅只加载在浏览器上，也慢慢流行于各种app的webview里。尤其在如今设备性能越来越好的条件下，前端页面更是开始在app中担任重要的角色。如此一来，前端页面的停留时间变得更长，我们理应越发重视前端的内存管理，防止内存泄露，提高页面的性能。

想要打造高性能前端应用，防止崩溃，就必须得搞清楚JS的内存机制，其实就是弄清楚JS内存的分配与回收。

# 内存泄漏
内存泄漏就是指由于疏忽或者程序的某些错误造成**未能释放已经不再使用的内存的情况**

JavaScript的内存空间分为栈内存和堆内存，前者用来存放一些简单变量，后者用来存放复杂对象

简单变量指的是JS的基本数据类型，例如：String、Number、Boolean、null、undefined、Symbol、BigInt

复杂对象指的是JS的引用数据类型，例如：Object、Array、Function

## 闭包
浏览器在创建一个函数的时候，会为这个函数创建一个clouse空间存储属于这个函数下的闭包对象，一个函数内存在变量被其内部其他函数引用就被放到clouse对象中，如果函数存在闭包，其所有内部函数都会拥有一个指向这个闭包的引用，即所有内部函数会共享同一个闭包，只要任意内部函数有引用外部函数中声明的变量，这个变量都会被纳入闭包内，而且最内部的函数会持有所有外部的闭包。

# 变量存储

## 代码空间
用来存放可执行代码
## 栈空间
栈存储基础类型,存储和使用方式后进先出,存储引用类型的变量，但实际上保存的不是变量本身，而是指向该对象的指针(在堆内存中存放的地址)。

所有方法中定义的变量存在栈中，方法执行结束，这个方法的内存栈也自动销毁可以递归调用方法，这样随着栈深度增加，JVW维持一条长长的方法调用轨迹，内存不够分配，会产生栈溢出。

自动分配内存空间，自动释放，占固定大小的空间。一块连续的内存区域，容量较小，读取速度快，被设计成先进后出结构。

**通常情况下，栈空间都不会设置太大，这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。**

## 堆空间
存储引用类型：Object（Function/Array/Date/RegExp)，动态分配内存空间，大小不定也不会自动释放，堆内存中的对象不会因为方法执行结束就销毁，因为有可能被另一个变量引用(参数传递等)。不连续的内存区域，容量较大，用于储存大数据，读取速度慢。

## 为什么会有栈和堆之分

通常与垃圾回收机制有关。每一个方法执行时都会建立自己的内存栈，然后将方法里的变量逐个放入这个内存栈中，随着方法执行结束，这个方法的内存栈也会自动销毁。为了使程序运行时占用的内存最小，栈空间都不会设置太大，而堆空间则很大。每创建一个对象时，这个对象会被保存到堆中，以便反复复用，即使方法执行结束，也不会销毁这个对象，因为有可能被另一个变量(参数传递等)引用，直到对象没有任何引用时才会被系统的垃圾回收机制销毁。而且JS引擎需要用栈来维护程序执行期间上下文的状态，如果所有的数据都在栈里在，栈空间大了的话，会影响到上下文切换的效率，进而影响整个程序的执行效率。


# 堆栈存放的数据类型
调用栈中的引用类型存放在堆中，相信大家都没有问题，但是原始类型真的都存放在栈中吗？

## 数字
V8把数字分成两种类型：smi 和 heapNumber。smi是范围为 ：-2³¹ 到 2³¹-1的整数，在栈中直接存值；除了smi，其余数字类型都是heapNumber，需要另外开辟堆空间进行储存，变量保存其引用。

## 更基本的基本类型
V8定义了一种 oddball 类型，属于 oddball 类型的有null、undefined、true和false

这里可以看到oddball类型以及空字符串的堆引用全部都是一个固定值，代表在V8跑起来的第一时间，不管我们有没有声明这些基本类型，他们都已经在堆中被创建完毕了。由此猜想栈中这些类型使用的也是堆中的地址。

## bigInt、string、symbol
```
function Obj() {
  this.string = 'str';
  this.num1 = 1;
  this.num2 = 1.1;
  this.bigInt = BigInt('1');
  this.symbol = Symbol('1');
}
const obj = new Obj();
debugger;
obj.string = 'other str';
obj.num1 = 2;
obj.num2 = 1;
obj.bigInt = BigInt('2');
obj.symbol = Symbol('2');
```
debugger 前后的快照对比

其中bigInt、string、symbol的内存地址都进行了更换，由此可以猜想是因为这三种类型占用的内存大小不是一个固定值，需要根据其值进行动态分配，所以内存地址会进行更换；而heapNumber的内存地址并没有发生变化，这个更换值的操作还是在原来的内存空间中进行。因为栈是一块连续的内存空间，不希望运行中会产生内存碎片，由此可以得出bigInt、string、symbol这些内存大小不固定的类型在栈中也是保存其堆内存的引用。同时我们在栈中可以声明很大的string，如果string存放在栈中明显也不合理

查看快照的方式---- Profile(内存) --- 点击生成快照（take heap snapshot）

num1的值始终没有在前后两次快照中展示，是因为num1存放在栈中 所以没在堆快照中展示
**故栈空间中的基本类型储存位置如下**

类型	储存位置
Number	smi储存栈中，heapNumber储存堆中
String	堆
Boolean	堆
Null	堆
undefined	堆
BigInit	堆
Symbol	堆

# JS内存回收

## 栈内存回收
```
function fn1() {
  //....
  function fn2() {
    //...
  }
  fn2();
}
fn1();
```
调用栈中有一个记录当前执行状态的指针（称为 ESP），随着函数的执行，函数执行上下文被压入调用栈中，执行上下文中的数据会按照前面说的JS数据存储机制被分配到堆栈中，ESP会指向最后压栈的执行上下文，如左图所示的fn2函数。当fn2函数调用完毕，JS 会把ESP指针下移至fn1函数，这个指针下移的操作就是销毁fn1函数执行上下文的过程。最后fn1函数执行上下文所占用的区域会变成无效区域，下一个函数执行上下文压入调用栈的时候会直接覆盖其内存空间。简而言之，只要函数调用结束，该栈内存就会自动被回收，不需要我们操心。刚刚我们也聊到闭包，如果出现闭包的情况，闭包的数据就会组成一个对象保存在堆空间里。**递归调用函数应当给函数写return 来优化递归调用栈** 写了return 引擎才会识别将函数推出栈中。

## 堆内存回收
内存垃圾回收领域中有个重要术语：代际假说，其有以下两个特点：

大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
不死的对象，会活得更久。

基于代际假说，JS 把堆空间分成新生代和老生代两个区域，新生代中存放的是生存时间短的对象，通常只支持 1～8M 的容量；老生代中存放的生存时间长的对象，一些大的数据也会被直接分配到老生区中。而针对这两个区域，JS 存在两个垃圾回收器：主垃圾处理器和副垃圾处理器。这里先说说垃圾回收一般都有相同的执行流程：

标记空间中活动对象和非活动对象
回收非活动对象所占据的内存
内存整理，这步是可选的，因为有的垃圾回收器工作过程会产生内存碎片，这时就需要内存整理防止不够连续空间分配给大数据。

副垃圾回收器
副垃圾回收器主要是采用 Scavenge 算法进行新生区的垃圾回收，它把新生区划分为两个区域：对象区域和空闲区域，新加入的对象都会存放到对象区域，当对象区域快被写满时，会对对象区域进行垃圾标记，把存活对象复制并有序排列至空闲区域，完成后让这两个区域角色互转，由此便能无限循环进行垃圾回收。同时存在对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

主垃圾回收器
由于老生区空间大，数据大，所以不适用 Scavenge 算法，主要是采用标记-整理算法，其工作流程是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。接着让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。垃圾回收工作是需要占用主线程的，必须暂停JS脚本执行等待垃圾回收完成后恢复，这种行为称为全停顿。 由于老生代内存大，全停顿对性能的影响非常大，所以出现了增量标记的策略进行老生区的垃圾回收。

# 垃圾回收机制
JS具有自动垃圾回收机制，会定期对无效变量进行回收

## 引用计数法

当我们用一个变量指向一个值时，就创建了一个针对这个值的 “引用”,在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为0时，就会将它的内存释放掉。

### 缺点

无法判断循环引用场景下的 “垃圾”，这也是它退出历史舞台的原因。需要一个计数器，而此计数器需要占很大的位置

### 优点

首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾。而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了。

## 标记清除法

在标记清除算法中，根据变量是否可抵达，来决定是否清除。这个算法有两个阶段，分别是标记阶段和清除阶段

### 标记阶段
垃圾收集器会先找到根对象，从根对象出发，扫描所有可以通过根对象触及的变量，这些变量会被标记为 “可抵达”

### 清除阶段
没有被标记为 “可抵达” 的变量，就会被清除

### 优点
实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单。

### 缺点
标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了内存碎片。并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。

假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配，那如何找到合适的块呢？我们可以采取下面三种分配策略：

* First-fit，找到大于等于 size 的块立即返回

* Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块

* Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回

这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择。


## v8对垃圾回收的优化---新生代和老生代（分代式垃圾回收机制）

V8实现了GC算法，采用了分代式垃圾回收机制，所以V8将堆内存分为新生代(副垃圾回收器)和老生代(主垃圾回收器)两个部分

### 新生代

新生代中通常只支持1~8M的容量，所以主要存放生存时间较短的对象。将新生代空间分为两个区域：对象区域和空闲区域。

[image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc1391485c840bdbede249e4fdd6058~tplv-k3u1fbpfcp-watermark.awebp)

将新分配的对象存入对象区域中，当对象区域存满了，就会启动GC算法。对对象区域内的垃圾做标记，标记完成之后将对象区域中还存活的对象复制到空闲区域中，已经不用的对象就销毁。这个过程不会留下内存碎片。复制完成后，再将对象区域和空闲互换。既回收了垃圾也能让新生代中这两块区域无限重复使用下去

### 老生代

老生代特点就是占用空间大，所以主要存放存活时间长的对象。老生代中使用标记清除算法和标记压缩算法。因为如果也采用Scavenge GC算法的话，复制大对象就比较花时间了标记清除在以下情况下会先启动标记清除算法。标记清除的流程是这样的从根部(js的全局对象)出发，遍历堆中所有对象，然后标记存活的对象。标记完成后，销毁没有被标记的对象


## 减少垃圾回收
虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。

### 优化方法

1.对数组进行优化：通过将数组的长度设置为0，以此来清空数组	//如果给数组赋值为[]，会同时会创建一个新的空对象
2.对对象进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收
3.生命周期清除
4.使用WeakMap、WeakSet

## 内存泄漏的情况

### 意外的全局变量

第一种
```
function foo(arg) {
    bar = "this is a hidden global variable";
}
bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。
```
第二种
```
另一种意外的全局变量可能由 this 创建:
function foo() {
    this.variable = "potential accidental global";
}
// foo 调用自己，this 指向了全局对象（window）
foo();
复制代码在 JavaScript 文件头部加上 'use strict'，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。
```

### 被遗忘的计时器或回调函数

### 闭包

### 没有清理的DOM元素引用
```
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function removeButton() {
    document.body.removeChild(document.getElementById('button'));
}
```
虽然我们用removeChild移除了button，但是还在elements对象里保存着#button的引用，换言之，DOM元素还在内存里面。

```

<div id="root">
  <ul id="ul">
    <li></li>
    <li></li>
    <li id="li3"></li>
    <li></li>
  </ul>
</div>
<script>
  let root = document.querySelector('#root')
  let ul = document.querySelector('#ul')
  let li3 = document.querySelector('#li3')
  
  // 由于ul变量存在，整个ul及其子元素都不能GC
  root.removeChild(ul)
  
  // 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC
  ul = null
  
  // 已无变量引用，此时可以GC
  li3 = null
</script>

```

```
<div id="my-div">
  <span>My Div</span>
  <ul>
    <li>Hero</li>
    <li>Cows</li>
    <li>Bugs</li>
  </ul>
</div>

<button onclick="deleteMyDiv()">Delete My Div</button>
<script>
const myDiv = document.querySelector('#my-div')

function deleteMyDiv () {
  myDiv.parentElement.removeChild(myDiv)
}
</script>

点击 "Delete My Div" 按钮时，节点 #my-div 不会消失

function getMyDiv () {
  return document.querySelector('#my-div')
}

function deleteMyDiv () {
  const myDiv = getMyDiv()
  myDiv.parentElement.removeChild(myDiv)
}

```

# React中的内存泄漏

现象： 当组件被销毁后，仍有一些异步事件调用组件中setState方法

原理： 组件销毁后，再调用setstate方法会保留相关引用，造成内存泄漏

```
// 测试代码
const [test, setTest] = useState(null);
useEffect(() => {
  (async () => {
    // 这里表达一个异步操作如：xhr、fetch、promise等等
    await sleep(3000);
    const obj = new TestObj();
    setTest(obj);
  })();
}, []);
```
如果把代码改成这样，就不会造成内存泄漏：
```
const [test, setTest] = useState(null);
useEffect(() => {
  let unMounted = false;
  (async () => {
    await sleep(3000);
    if (unMounted) return;
    const obj = new TestObj();
    setTest(obj);
  })();
  return () => {
    unMounted = true;
  };
}, []);
```