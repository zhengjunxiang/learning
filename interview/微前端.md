# 微服务架构概念
[原文链接](https://www.zhihu.com/question/65502802)
[原文链接 不错](https://juejin.cn/post/7163481140165246983)
## 概念
概念从后端而来，后端存在多个应用交叉使用数据库和交叉使用数据库服务的操作，一个接口改数据库造成问题或者修改一个服务出问题都会造成其他接口出现问题。因此将多个服务对应的数据库拆分出来并且建立属于各个数据库的服务。
## 缺点
微服务架构整个应用分散成多个服务，定位故障点非常困难。稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。服务数量非常多，部署、管理的工作量很大。开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。

# 微前端概念
微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。微前端不是单纯的前端框架或者工具，而是一套架构体系。

## 解决的问题

### 拆分和细化
当下前端领域，单页面应用（SPA）是非常流行的项目形态之一，而随着时间的推移以及应用功能的丰富，单页应用变得不再单一而是越来越庞大也越来越难以维护，往往是改一处而动全身，由此带来的发版成本也越来越高。微前端的意义就是将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。
### 整合历史系统
在不少的业务中，或多或少会存在一些历史项目，这些项目大多以采用老框架类似（Backbone.js，Angular.js 1）的B端管理系统为主，介于日常运营，这些系统需要结合到新框架中来使用还不能抛弃，对此我们也没有理由浪费时间和精力重写旧的逻辑。而微前端可以将这些系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行。

# 实现微前端的方案

微前端的重要思想就是将应用进行拆解和整合，通常是一个父应用加上一些子应用，那么使用类似Nginx配置不同应用的转发，或是采用iframe来将多个应用整合到一起等等这些其实都属于微前端的实现方案，他们之间的对比如下图：

## MPA

严格意义上来说 MPA 可能不算是标准的微前端方案，用户在使用过程中可能会存在一些体验上的割裂感。就好比去超市买菜，MPA 超市的服务员告诉你：“白菜我们这没有了，我给你个地址你去其他店买吧。”虽然最终也买到了，但是花费了更多时间。
更好的做法应该是：“白菜我们这没有了，我立刻帮你从其他超市进货过来。”用户不用经历 出超市->找路->进超市 的过程就买到了菜。

将系统分为多个仓库维护，在首页聚合所有平台的入口或提供统一的导航组件，采用 MPA（Multi-page Application）多页应用模式。
如下图所示应用的导航部分记录了所有子应用的入口地址，用户点击后会跳转到对应的子平台地址。公共导航部分需要抽离成组件给子平台使用。


微前端场景下的缺陷：

只能以页面维度拆分，无法拆分至区块部分。

用户在使用时体验割裂，会在不同平台间跳转，无法达到 SPA 应用带来的用户体验。

不同系统间不可以直接通信。

公共部分更新时，同一运维通知困难。
## Nginx路由转发	
通过Nginx配置反向代理来实现不同路径映射到不同应用，例如www.abc.com/app1对应app1，www.abc.com/app2对应app2，这种方案本身并不属于前端层面的改造，更多的是运维的配置。

经历过早期前端开发的同学可能都会有印象，在 webpack、react、vue 等框架大行其道前。我们常会使用 hbs、ejs 等页面模板框架来开发我们的前端页面。在服务端根据请求路径做静态模板拼接，来返回相应的页面结构。

[dizhi](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd46681ee2fa449c895a884c429374fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

[dizhi2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd7cb35445bc4ec282eed7f67b198fa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
### 优点
简单，快速，易配置
### 缺点
在切换应用时会触发浏览器刷新，影响体验

## 构建时组合 npm
通过将子应用打包为 npm 包，在主应用中作为依赖库引入。

[dizhi](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/866301703c28434e9eb27631a940a37f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

微前端场景下的缺陷：

涉及子应用改造，需要打包为 npm 包成本较高。

升级维护麻烦，需要子应用更新包版本，主应用修改后重新发布。

子应用间公用依赖包重复引入。

## 模块联邦
模块联邦是一个 webpack5 提供的新特性。既可以做到打包发布模块供给后，消费者能够实时保持同步，也可以进行代码构建时候的优化。可以在一个应用中直接导出或使用另一个应用的模块。
## iframe嵌套	
父应用单独是一个页面，每个子应用嵌套一个iframe，父子通信可采用postMessage或者contentWindow方式

在浏览器中组合应用程序的最简单的方法之一就是 iframe。从本质上讲，iframe 使从独立的子页面构建页面变得很容易。它们还在样式和全局变量不相互干扰方面提供了良好的隔离程度。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

### 优点
实现简单，子应用之间自带沙箱，天然隔离，互不影响

### 缺点
iframe的样式显示、兼容性等都具有局限性；太过简单而显得low

URL 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。

UI 不同步，DOM 结构不共享。如无法显示整页弹窗。

全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。

加载慢，每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

## JS 加载子应用
通过 JS 加载子应用是最灵活的方法，也是目前最常采用的方法。每个子应用按约定暴露出相应的生命周期钩子，并且在加载后将其绑定到 window 对象下给主应用访问。然后主应用程序确定渲染哪个子应用，调用相关渲染函数传入渲染节点。（以下代码仅做示意）

[dizhi](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0474bd7ec4d64eeba1978356f520fb3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 乾坤

基于 single-spa 实现路由与子应用的绑定关系根据路由加载相应应用。子应用将自己的信息注册到主应用中，包括入口文件地址、对应生效路由及命名空间等信息。同时子应用需暴露几个关键的生命周期钩子bootstrap、mount、unmount，以供主应用在适当的时机调用。
提供两套 JS 沙箱方案（具体实现方案见下文）：

在不支持 proxy 的环境下用快照的方式在加载子应用前记录全局状态并在卸载时还原记录的状态。
在支持 proxy 时，劫持对 window 的操作并创建一个 fakeWindow 对象，赋值操作都发生在 fakeWindow 对象下，取值时按照 fakeWindow -> window 的顺序依次查找。

CSS 隔离方案（具体实现方案见下文）：
通过为每个 css 规则添加特定的前缀来起到隔离的作用，例如微应用中的样式是 p{color:#000} ，处理后为 .app1 p {color:#000} 。

相比而言乾坤是目前微前端框架中比较成熟且用户最多的框架了，基本解决了大部分微前端开发中会遇到的问题。但是也存在一些接入成本，需要对子应用做一些改造（umd 打包，暴露 hook 等）。

## 无界

基于 iframe 实现 js 沙箱，通过 WebComponent 处理 css 隔离。（详见）
大致实现方式为：运行时动态加载子应用资源（加载方式在下文技术细节中会详细说明），在主应用中创建一个 shadowdom 节点和一个 iframe。将 js 注入 iframe 内运行，将 dom、css 放到 shadowdom 节点下。同时劫持 js 中的 dom 操作并指向 shadowdom。
在路由状态方面 通过劫持iframe的history.pushState和history.replaceState将子应用的url同步到主应用的query参数上，当刷新浏览器初始化iframe时，读回子应用的url并使用iframe的history.replaceState进行同步。

[地址](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2775ae22b54e0ba01f683b62690e25~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
## Web Components
WebComponent 的实现将子应用包裹为一个 HTML 自定义元素供容器实例化，而不是要求子应用暴露一些供容器调用的全局函数，同时借助于 shadowdom 的隔离能力可以有更好的样式隔离性。

[地址](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aac46d467f644cc906e9e977532c13f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)
### 优点
每个子应用拥有独立的script和css，也可单独部署

### 缺点
对于历史系统改造成本高，子应用通信较为复杂易踩坑

## 组合式应用路由分发	

每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载，启动，卸载，以及通信机制

### 优点
纯前端改造，体验良好，可无感知切换，子应用相互隔离

### 缺点

需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突，变量对象污染，通信机制等技术点

## micro-app
micro-app借鉴了 WebComponent 的思想，通过 CustomElement 结合自定义的 ShadowDom，将微前端封装成一个类 WebComponent 组件，从而实现微前端的组件化渲染。并且由于自定义 ShadowDom 的隔离特性，micro-app不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改 webpack 配置，接入成本较低。

需要注意的是 shadowDOM 在 React 框架及一些 UI 库中的兼容不是很好，经常会出现一些不可预料的问题。如在 react16 及以下的版本中，在 shadowDOM 下绑定合成事件时会出现不触发的情况。（详见）
实际在 micro-app 中默认也不会开启 shadowDOM 的能力。
# 讲一下组合式应用路由分发模块组成

基于上文，当下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示

[图示讲解](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/1721766ee9a543cf~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)
## 主工程包含的内容

有一些访问用户信息的主要逻辑
路由分发组件监听url变化
应用加载器(加载子应用)
应用管理服务(各个子应用之间通信)

一个微前端框架内可以运行多种框架编译出的代码文件，包含react、vue、jquery等

## 主工程需要解决的问题

* 路由切换的分发问题
* 主微应用的隔离问题
* 通信问题
  
### 路由分发问题

作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。
远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。
当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考import-html-entry和system.js。

对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：

当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。
最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。

### 微前端的应用隔离
应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。

#### CSS隔离
当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。
而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。

#### JavaScript隔离
每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。
沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。

### 微前端的消息通信
应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：
[流程图地址](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/17/1722065f24632ddb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)
当然，如果基座和微应用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。

是否要用微前端
微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：


微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。


整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：
1)：基座应用和微应用的自动部署能力。
2)：微应用的配置管理能力。
3)：本地开发调试能力。
4)：线上监控和统计能力等等。
只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。


当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。


# 微前端要注意的点

JS隔离、CSS隔离、公共逻辑的抽离、路由丢失、通信方式。
选择方案要根据框架实现选择贴切项目的定制方案。

路由丢失问题：每个子应用都渲染相同的导航栏，每个子应用301重定向。每个子应用都要更新导航栏会有闪动问题。

单实例：只有一个子应用处于挂载状态
多实例：多个子应用处于挂载状态

安全性不好 js error会影响住应用 可以操作主应用dom

cssModule、shawdowDom Proxy代理每个子应用伪造window Proxy的好处是如果子应用没有属性还可以去主应用去找。

## CSS Modules 
[原文链接](https://juejin.cn/post/6952665769209495566)
[原文链接](https://www.ruanyifeng.com/blog/2016/06/css_modules.html)
所有的类名和动画名称默认都有各自的作用域的 CSS 文件。CSS Modules 并不是 CSS 官方的标准，也不是浏览器的特性，而是使用一些构建工具，比如 webpack，对 CSS 类名和选择器限定作用域的一种方式（类似命名空间）







