### 栈
后进先出。新添加的或待删除的元素都保存在栈的末尾。称作栈顶，另一端就叫栈底。

```
function Stack() {
  var items = [];
  this.push = function(element){//添加一个（或几个）新元素到栈顶
    items.push(element);
  };
  this.pop = function(){//移除栈顶的元素，同时返回被移除元素
    return items.pop();
  };
  this.peek = function(){//返回栈顶的元素，但并不对栈做任何修改
    return items[items.length-1];
  };
  this.isEmpty = function(){//如果栈内没有任何元素就返回true，否则返回false
    return items.length == 0;
  };
  this.size = function(){//返回栈里的元素个数
    return items.length;
  };
  this.clear = function(){//移除栈里的所有元素
    items = [];
  };
  this.print = function(){//打印
    console.log(items.toString());
  };
  this.toString = function(){
    return items.toString();
  };
}
```
##### 将10进制数字转成任意进制数字

```
function baseConverter(decNumber,base){
  var remStack = new Stack(),
  rem,
  baseString = "",
  digits = "0123456789ABCDEF";

  while(decNumber > 0){
    rem = Math.floor(decNumber % base);
    remStack.push(rem);
    decNumber = Math.floor(decNumber / base);
  }
  while(!remStack.isEmpty()){
    baseString += digits[remStack.pop()];
  }
  return baseString;
} 
baseConverter(100345,2) // "11000011111111001"
baseConverter(100345,8) //"303771"
baseConverter(100345,16) // "187F9"   
```
### 队列
先进先出，队列从尾部添加新元素，并从顶部移除元素，最新添加的元素必须排列在队列的末尾。

```
function Queue() {
  var items = [];
  this.enqueue = function(element){//向队列尾部添加一个（或是多个）元素
    items.push(element);
  };
  this.dequeue = function(){//移除队列的第一个元素，并返回被移除的元素
    return items.shift();
  };
  this.front = function(){//返回队列的第一个元素——最先被添加的,也将是最先被移除的元素。队列不做任何变动。（不移除元素，只返回元素信息。与stack的peek方法类似）
    return items[0];
  };
  this.isEmpty = function(){//如果队列内没有任何元素就返回true，否则返回false
    return items.length == 0;
  };
  this.clear = function(){//移除队列里的所有元素
    items = [];
  };
  this.size = function(){//返回队列里的元素个数
    return items.length;
  };
  this.print = function(){//打印                          
    console.log(items.toString());
  };
 }
```
### 优先队列
队列元素的添加和移除是基于优先级的。实现一个优先队列，有两种选项：设置优先级，然后再正确的位置添加元素；或者用入队操作添加元素，然后按照优先级移除他们。下例将会在正确的位置添加元素，如下：
```
function PriorityQueue(){
  var items = [];
  function QueueElement(element, priority){
    this.element = element;
    this.priority = priority;
  }
  this.enqueue = function(element, priority){
    var queueElement = new QueueElement(element, priority);
    if(this.isEmpty()){
      items.push(queueElement);
    }else{
      var added = false;
      for(var i = 0; i < items.length; i++){
          if(queueElement.priority < items[i].priority){
            items.splice(i,0,queueElement);
            added = true;
            break;
          }
      }
    } 
    if(!added){
      items.push(queueElement);
    }
  }
  this.dequeue = function(){
    return items.shift();
  };
  this.front = function(){
    return items[0];
  };
  this.isEmpty = function(){
    return items.length == 0;
  };
  this.size = function(){
    return items.length;
  };
  this. print = function(){
    for (var i=0; i<items.length; i++){
        console.log(items[i].element + ' - ' + items[i].priority);
    }
  };
}
```
### 循环队列——击鼓传花
击鼓传花游戏，在这个游戏中，孩子们围成一个圆圈，把花尽快的传递给旁边的人。某一时刻传花停止，这个时候花落在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩下一个孩子。

```
function hotPotato(namelist, num){
  var queue = new Queue();
  for(var i = 0; i < namelist.length; i++){
    queue.enqueue(namelist[i]);
  }
  var eliminated = '';
  while(queue.size() > 1){
    for(var i = 0; i < num; i++){
      queue.enqueue(queue.dequeue());
    }
    eliminated = queue.dequeue();
    console.log(eliminated+"在游戏中淘汰了。");
  }
  return queue.dequeue();
}
var names = ["a","b","c","d","e"];
var winner = hotPotato(names,7);
console.log("胜利者"+winner);
//c在游戏中淘汰了。
//b在游戏中淘汰了。
//e在游戏中淘汰了。
//d在游戏中淘汰了。
//胜利者a

```
### 链表 
链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本事的节点和一个指向下一个元素的引用组成。相对于传统的数组，链表的一个好处在于，添加或者删除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。
##### 单向链表

```
function LinkedList() {
    var Node = function(element){
        this.element = element;
        this.next = null;
    };
    var length = 0;//链表长度
    var head = null;//第一个节点
    this.append = function(element){
        var node = new Node(element),
            current;
        if (head === null){ //列表为空
            head = node;
        } else { //列表不为空
            current = head; //现在只知道第一项head
            while(current.next){ //找到列表的最后一项
                current = current.next;
            }
            //建立链接
            current.next = node;
        }
        length++; //更新列表长度
    };
    this.insert = function(position, element){
        //检查越界值
        if (position >= 0 && position <= length){
            var node = new Node(element),
                current = head,
                previous,
                index = 0;
            if (position === 0){ //在第一个位置添加
                node.next = current;
                head = node;
            } else { //在中间或者尾部添加
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                node.next = current; //先连上添加的节点
                previous.next = node; //再断开之前的连接
            }
            length++; 
            return true;
        } else {
            return false;
        }
    };
    this.removeAt = function(position){
        if (position > -1 && position < length){
            var current = head,
                previous,
                index = 0; //用来迭代列表，直到到达目标位置
            if (position === 0){ //移除第一项
                head = current.next;
            } else { //移除中间或者尾部最后一项
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                //连接前一项和后一项，跳过当前的项，相当于移除了当前项
                previous.next = current.next;
            }
            length--;
            return current.element;
        } else {
            return null;
        }
    };
    this.remove = function(element){
        var index = this.indexOf(element);
        return this.removeAt(index);
    };
    this.indexOf = function(element){
        var current = head,
            index = 0;
        while (current) {
            if (element === current.element) {
                return index;
            }
            index++; //记录位置
            current = current.next;
        }
        return -1;
    };
    this.isEmpty = function() {
        return length === 0;
    };
    this.size = function() {
        return length;
    };
    this.getHead = function(){
        return head;
    };
    this.toString = function(){
        var current = head,
            string = '';
        while (current) {
            string += current.element;//拼接
            current = current.next;
        }
        return string;
    };
    this.print = function(){
        console.log(this.toString());
    };
}

```
##### 双向链表
双向链表和单向链表的区别在于，在单向链表中，一个节点只有链向下一个节点的链接。而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。示例代码如下：
```
function DoublyLinkedList() {
    var Node = function(element){
        this.element = element;
        this.next = null;
        this.prev = null; //新添加的
    };
    var length = 0;
    var head = null;
    var tail = null; //新添加的
    this.append = function(element){
        var node = new Node(element),
            current;
        if (head === null){ //列表为空
            head = node;
            tail = node; 
        } else {
            tail.next = node;
            node.prev = tail;
            tail = node;
        }
        length++; 
    };
    this.insert = function(position, element){
        if (position >= 0 && position <= length){
            var node = new Node(element),
                current = head,
                previous,
                index = 0;
            if (position === 0){ //在第一个位置
                if (!head){       //列表为空
                    head = node;
                    tail = node;
                } else {      //列表不为空
                    node.next = current;
                    current.prev = node; 
                    head = node;
                }
            } else  if (position === length) { //最后一项
                current = tail;     
                current.next = node;
                node.prev = current;
                tail = node;
            } else {
                while (index++ < position){ 
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node; //把node节点连接进去前一个节点和后一个节点

                current.prev = node; //断掉之前previous和current的连接
                node.prev = previous; //prev同样需要连接
            }
            length++; 
            return true;
        } else {
            return false;
        }
    };
    this.removeAt = function(position){
        if (position > -1 && position < length){
            var current = head,
                previous,
                index = 0;
            if (position === 0){ //移除第一项
                head = current.next; 
                if (length === 1){ // 列表只有一项
                    tail = null;
                } else {
                    head.prev = null; 
                }
            } else if (position === length-1){ 移除最后一项
                current = tail; // {4}
                tail = current.prev;
                tail.next = null;
            } else {
                while (index++ < position){ 
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next; // 链接前一项和后一项，跳过当前项
                current.next.prev = previous; //修复prev
            }
            length--;
            return current.element;
        } else {
            return null;
        }
    };
    this.remove = function(element){
        var index = this.indexOf(element);
        return this.removeAt(index);
    };
    this.indexOf = function(element){
        var current = head,
            index = -1;
        //检查第一项
        if (element == current.element){
            return 0;
        }
        index++;
        //检查中间项
        while(current.next){
            if (element == current.element){
                return index;
            }
            current = current.next;
            index++;
        }
        //检查最后一项
        if (element == current.element){
            return index;
        }
        return -1;
    };
    this.isEmpty = function() {
        return length === 0;
    };
    this. size = function() {
        return length;
    };
    this.toString = function(){
        var current = head,
            s = current ? current.element : '';
        while(current && current.next){
            current = current.next;
            s += ', ' + current.element;
        }
        return s;
    };
    this.inverseToString = function() {
        var current = tail,
            s = current ? current.element : '';
        while(current && current.prev){
            current = current.prev;
            s += ', ' + current.element;
        }
        return s;
    };
    this.print = function(){
        console.log(this.toString());
    };
    this.printInverse = function(){
        console.log(this.inverseToString());
    };
    this.getHead = function(){
        return head;
    };
    this.getTail = function(){
        return tail;
    }
}
```
#####  循环链表
循环链表可以像单向链表那样只有单向引用，也可以像双向链表那样有双向引用。循环链表和其他链表的区别在于最后一个元素指向下一个元素的引用不是null，而是指向第一个元素（head）。
```
function CircularLinkedList() {
    var Node = function(element){
        this.element = element;
        this.next = null;
    };
    var length = 0;
    var head = null;
    this.append = function(element){
        var node = new Node(element),
            current;
        if (head === null){ //列表为空
            head = node;
        } else {
            current = head;
            while(current.next !== head){ //最后一个元素将是head，而不是null
                current = current.next;
            }
            current.next = node; //建立连接
        }
        node.next = head; //首尾相连起来变成一个环列表
        length++; 
    };
    this.insert = function(position, element){
        if (position >= 0 && position <= length){
            var node = new Node(element),
                current = head,
                previous,
                index = 0;
            if (position === 0){ //在第一项
                node.next = current;
                while(current.next !== head){ 
                    current = current.next;
                }
                head = node;
                current.next = head;
            } else {
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
                if (node.next === null){ //在最后一个元素更新
                    node.next = head;
                }
            }
            length++; 
            return true;
        } else {
            return false;
        }
    };
    this.removeAt = function(position){
        if (position > -1 && position < length){
            var current = head,
                previous,
                index = 0;
            if (position === 0){
                while(current.next !== head){ 
                    current = current.next;
                }
                head = head.next;
                current.next = head; //更新最后一项
            } else { 
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;
            }
            length--;
            return current.element;
        } else {
            return null;
        }
    };
    this.remove = function(element){
        var index = this.indexOf(element);
        return this.removeAt(index);
    };
    this.indexOf = function(element){
        var current = head,
            index = -1;
        if (element == current.element){ //检查第一项
            return 0;
        }
        index++;
        while(current.next !== head){ //检查列表中间
            if (element == current.element){
                return index;
            }
            current = current.next;
            index++;
        }
        if (element == current.element){ //检查最后一项
            return index;
        }
        return -1;
    };
    this.isEmpty = function() {
        return length === 0;
    };
    this.size = function() {
        return length;
    };
    this.getHead = function(){
        return head;
    };
    this.toString = function(){
        var current = head,
            s = current.element;
        while(current.next !== head){
            current = current.next;
            s += ', ' + current.element;
        }
        return s.toString();
    };
    this.print = function(){
        console.log(this.toString());
    };
}
```
### 树
##### 二叉树和二叉搜索树
二叉树中的节点最多只能有两个节点：一个是左侧子节点，另一个是右侧子节点。二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。下面示例（BST）的代码：
```
function BinarySearchTree() {
    var Node = function(key){ //数据结构类
        this.key = key;
        this.left = null;
        this.right = null;
    };
    var root = null; //根节点
    this.insert = function(key){ //插入新的键
        var newNode = new Node(key);
        //special case - first element
        if (root === null){ //根节点为空，作为根节点
            root = newNode;
        } else {
            insertNode(root,newNode); //插入节点操作
        }
    };
    var insertNode = function(node, newNode){
        if (newNode.key < node.key){
            if (node.left === null){ //如果没有左侧节点就插入新的节点
                node.left = newNode;
            } else { //有的话递归
                insertNode(node.left, newNode);
            }
        } else {
            if (node.right === null){  //如果没有右侧节点就插入新的节点
                node.right = newNode;
            } else { //有的话递归
                insertNode(node.right, newNode);
            }
        }
    };
    this.getRoot = function(){
        return root;
    };
    this.search = function(key){  //搜索键
        return searchNode(root, key); //搜索操作
    };
    var searchNode = function(node, key){
        if (node === null){
            return false;
        }
        if (key < node.key){ //如果小于继续从左边搜索
            return searchNode(node.left, key);
        } else if (key > node.key){ //如果大于继续从右边搜索
            return searchNode(node.right, key);
        } else { //命中
            return true;
        }
    };
    this.min = function() { //找最小键
        return minNode(root);
    };
    var minNode = function (node) {
        if (node){
            while (node && node.left !== null) {
                node = node.left;
            }
            return node.key;
        }
        return null;
    };
    this.max = function() { //找最大键
        return maxNode(root);
    };
    var maxNode = function (node) {
        if (node){
            while (node && node.right !== null) {
                node = node.right;
            }
            return node.key;
        }
        return null;
    };
    this.remove = function(element){
        root = removeNode(root, element);
    };
    var findMinNode = function(node){ //返回节点
        while (node && node.left !== null) {
            node = node.left;
        }
        return node;
    };
    var removeNode = function(node, element){ //移除一个节点
        if (node === null){
            return null;
        }
        if (element < node.key){
            node.left = removeNode(node.left, element);
            return node;
        } else if (element > node.key){
            node.right = removeNode(node.right, element);
            return node;
        } else { //命中后分三种情况         
            //移除叶子节点，即该节点没有左侧或者右侧子节点的叶结点
            if (node.left === null && node.right === null){
                node = null;
                return node;
            }
            //移除有一个左侧或者右侧子节点的节点
            if (node.left === null){
                node = node.right; //把引用改为子节点的引用，下同
                return node;
            } else if (node.right === null){
                node = node.left;
                return node;
            }
            //移除有两个子节点的节点
            var aux = findMinNode(node.right); //找到右边子树的最小节点
            node.key = aux.key; //改变节点的键，更新节点的值
            node.right = removeNode(node.right, aux.key); //移除有相同键的节点
            return node; //返回更新后节点的引用
        }
    };
}
```
### 字典
字典存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称映射。

```
function Dictionary(){
    var items = {};
    this.set = function(key, value){
        items[key] = value; 
    };
    this.remove = function(key){
        if (this.has(key)){
            delete items[key];
            return true;
        }
        return false;
    };
    this.has = function(key){
        return items.hasOwnProperty(key);
    };
    this.get = function(key) {
        return this.has(key) ? items[key] : undefined;
    };
    this.clear = function(){
        items = {};
    };
    this.size = function(){
        return Object.keys(items).length;
    };
    this.keys = function(){
        return Object.keys(items);
    };
    this.values = function(){
        var values = [];
        for (var k in items) {
            if (this.has(k)) {
                values.push(items[k]);
            }
        }
        return values;
    };
    this.each = function(fn) {
        for (var k in items) {
            if (this.has(k)) {
                fn(k, items[k]);
            }
        }
    };
    this.getItems = function(){
        return items;
    }
}
```
### 散列表
散列表即HashTable类，也叫HashMap类，是Dictionary类的一种散列实现方式。散列算法的作用是尽可能的在数据结构中找到一个值。在以前的系列中，如果要在数据结构中获取一个值，需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的位置。

```
function HashTable() {
    var table = [];
    var loseloseHashCode = function (key) {  //(1)散列函数
        var hash = 0;
        for (var i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % 37;
    };
    var djb2HashCode = function (key) {  //(2)散列函数
        var hash = 5381;
        for (var i = 0; i < key.length; i++) {
            hash = hash * 33 + key.charCodeAt(i);
        }
        return hash % 1013;
    };
    var hashCode = function (key) {
        return loseloseHashCode(key);
    };
    this.put = function (key, value) { //根据所给的key通过散列函数计算出它在表中的位置，进而作映射
        var position = hashCode(key);
        console.log(position + ' - ' + key);
        table[position] = value;
    };
    this.get = function (key) {
        return table[hashCode(key)];
    };
    this.remove = function(key){
        table[hashCode(key)] = undefined;
    };
    this.print = function () {
        for (var i = 0; i < table.length; ++i) {
            if (table[i] !== undefined) {
                console.log(i + ": " + table[i]);
            }
        }
    };
}
```
### 处理散列表中的冲突
有时候一些键会有相同的键值。不同的的值在散列表中对应相同位置的时候，我们称其为冲突。此时，当我们通过相同的散列值去取属性值的时候会出现相互覆盖、数据丢失的情况。处理冲突有几种方法：分离链接，线性探查和双散列法，这里介绍前两种。
##### 分离链接
分离链接法包括为散列表的每个位置创建一个链表并将元素存储在里面。

```
function HashTableSeparateChaining(){
    var table = [];
    var ValuePair = function(key, value){ //新的辅助类来加入LinkedList实例的元素，用到之前的链表
        this.key = key;
        this.value = value;
        this.toString = function() {
            return '[' + this.key + ' - ' + this.value + ']';
        }
    };
    var loseloseHashCode = function (key) { //散列函数得出一个散列值key
        var hash = 0;
        for (var i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % 37;
    };
    var hashCode = function(key){
        return loseloseHashCode(key);
    };
    this.put = function(key, value){
        var position = hashCode(key);
        console.log(position + ' - ' + key);
        if (table[position] == undefined) { //判断是否被占据了
            table[position] = new LinkedList();
        }
        table[position].append(new ValuePair(key, value)); //LinkedList实例中添加一个ValuePair实例
    };
    this.get = function(key) {
        var position = hashCode(key);
        if (table[position] !== undefined  && !table[position].isEmpty()){
            var current = table[position].getHead();
            while(current.next){ //遍历链表来寻找键值
                if (current.element.key === key){
                    return current.element.value;
                }
                current = current.next;
            }
            //检查元素在链表第一个或最后一个节点的情况
            if (current.element.key === key){
                return current.element.value;
            }
        }
        return undefined;
    };
    this.remove = function(key){
        var position = hashCode(key);
        if (table[position] !== undefined){
            var current = table[position].getHead();
            while(current.next){ //遍历
                if (current.element.key === key){
                    table[position].remove(current.element);
                    if (table[position].isEmpty()){
                        table[position] = undefined;
                    }
                    return true;
                }
                current = current.next;
            }
            //检查元素在链表第一个或最后一个节点的情况
            if (current.element.key === key){
                table[position].remove(current.element);
                if (table[position].isEmpty()){
                    table[position] = undefined;
                }
                return true;
            }
        }
        return false;
    };
    this.print = function() {
        for (var i = 0; i < table.length; ++i) {
            if (table[i] !== undefined) {
               console.log(table[i].toString());
            }
        }
    };
}
```
##### 线性探查
当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。

```
function HashLinearProbing(){
    var table = [];
    var ValuePair = function(key, value){
        this.key = key;
        this.value = value;
        this.toString = function() {
            return '[' + this.key + ' - ' + this.value + ']';
        }
    };
    var loseloseHashCode = function (key) {
        var hash = 0;
        for (var i = 0; i < key.length; i++) {
            hash += key.charCodeAt(i);
        }
        return hash % 37;
    };
    var hashCode = function(key){
        return loseloseHashCode(key);
    };
    this.put = function(key, value){
        var position = hashCode(key);
        console.log(position + ' - ' + key);
        if (table[position] == undefined) { //如果没有元素存在加入
            table[position] = new ValuePair(key, value);
        } else { 
            var index = ++position;
            while (table[index] != undefined){ //有的话继续往后找，直到找到加入
                index++;
            }
            table[index] = new ValuePair(key, value);
        }
    };
    this.get = function(key) {
        var position = hashCode(key);
        if (table[position] !== undefined){
            if (table[position].key === key) {
                return table[position].value;
            } else {
                var index = ++position;
                while (table[index] === undefined || table[index].key !== key){ //循环迭代
                    index++;
                }
                if (table[index].key === key) { //验证key
                    return table[index].value;
                }
            }
        }
        return undefined;
    };
    this.remove = function(key){
        var position = hashCode(key);
        if (table[position] !== undefined){
            if (table[position].key === key) {
                table[position] = undefined;
            } else {
                var index = ++position;
                while (table[index] === undefined || table[index].key !== key){
                    index++;
                }
                if (table[index].key === key) {
                    table[index] = undefined;
                }
            }
        }
    };
    this.print = function() {
        for (var i = 0; i < table.length; ++i) {
            if (table[i] !== undefined) {
                console.log(i + ' -> ' + table[i].toString());
            }
        }
    };
}
```
### 回溯算法
具有限界条件的 DFS （Depth first search，深度优先搜索）算法称为回溯算法。
给你一个数n写出来所有中可能的括号集合

```
[
"((()))",
"(()())",
"(())()",
"()(())",
"()()()"
]
```
所谓回溯Backtracking都是这样的思路：在当前局面下，你有若干种选择。那么尝试每一种选择。如果已经发现某种选择肯定不行（因为违反了某些限定条件），就返回；如果某种选择试到最后发现是正确解，就将其加入解集。


```
对于这道题，有以下的限制条件：

1、如果左括号已经用完了，则不能再加左括号
2、如果已经出现的右括号和左括号一样多，则不能再加右括号了。因为那样的话新加入的右括号一定无法匹配。

结束条件是：
左右括号都已经用完。

把上面的思路写一下伪代码：

if (左右括号都已用完) {
  加入解集，返回
}
// 否则开始情况
if (还有左括号可以用) {
  加一个左括号，继续递归
}
if (右括号小于左括号) {
  加一个右括号，继续递归
}


 var generateParenthesis = function (n) {
    var ans = [];
    
    dfs(ans, '', 0, 0, n);
    
    return ans;
};

function dfs(ans, str, left, right, n) {
    if (left === n && right === n) ans.push(str);
    
    if (left < n) {
        dfs(ans, str + '(', left + 1, right, n);
    }
    
    if (right < left) {
        dfs(ans, str + ')', left, right + 1, n);
    }
}

console.log(generateParenthesis(3)); //  ["((()))", "(()())", "(())()", "()(())", "()()()"]
```

### 搜索算法
##### 顺序搜索

```
顺序或线性搜索是最基本的搜索算法。它的机制是，将一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法。
this.sequentialSearch = function(item){
      for (var i=0; i<array.length; i++){
          if (item === array[i]){
              return i;
          }
      }
      return -1;
  }; 
```
##### 二分搜索法

```
这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤：

选择数组的中间值

如果选中值是待搜索值，那么算法执行完毕。

如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。

如果待搜索值比选中值要大，则返回步骤1并在选中值右边的子数组中寻找。

this.binarySearch = function(item){
    this.quickSort();
    var low = 0,
        high = array.length - 1,
        mid, element;
    while (low <= high){
        mid = Math.floor((low + high) / 2);
        element = array[mid];
        if (element < item) {
            low = mid + 1;
        } else if (element > item) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
};
```

### 集合
集合是由一组无序且唯一的项组成的。
Set 视+0和-0为相同的值。另外，NaN和undefined都可以被存储在Set 中， NaN之间被视为相同的值（尽管 NaN !== NaN）。

```
function Set() {
    var items = {};
    this.has = function(value){ //判定值是否在集合中
        return items.hasOwnProperty(value);
    };
    this.add = function(value){ //向集合添加一个新的项
        if (!this.has(value)){
            items[value] = value;
            return true;
        }
        return false;
    };
    this.remove = function(value){ //从集合移除一个值
        if (this.has(value)){
            delete items[value];
            return true;
        }
        return false;
    };
    this.clear = function(){ //清空集合
        items = {};
    };
    this.size = function(){ //集合元素的个数
        var count = 0;
        for(var prop in items) {
            if(items.hasOwnProperty(prop))
                ++count;
        }
        return count;
    };
    this.values = function(){ //集合所有值的数组
        var keys = [];
        for(var key in items){
            keys.push(key);
        }
        return keys;
    };
    this.getItems = function(){ //获取集合
      return items;
    };
    this.union = function(otherSet){ //并集
        var unionSet = new Set(); 
        var values = this.values(); 
        for (var i=0; i<values.length; i++){
            unionSet.add(values[i]);
        }
        values = otherSet.values(); 
        for (var i=0; i<values.length; i++){
            unionSet.add(values[i]);
        }
        return unionSet;
    };
    this.intersection = function(otherSet){ //交集
        var intersectionSet = new Set(); 
        var values = this.values();
        for (var i=0; i<values.length; i++){ 
            if (otherSet.has(values[i])){    
                intersectionSet.add(values[i]); 
            }
        }
        return intersectionSet;
    };
    this.difference = function(otherSet){ //差集
        var differenceSet = new Set(); 
        var values = this.values();
        for (var i=0; i<values.length; i++){ 
            if (!otherSet.has(values[i])){   
                differenceSet.add(values[i]); 
            }
        }
        return differenceSet;
    };
    this.subset = function(otherSet){ //子集
        if (this.size() > otherSet.size()){ //子集的元素个数要小于otherSet的元素个数
            return false;
        } else {
            var values = this.values();
            for (var i=0; i<values.length; i++){
                if (!otherSet.has(values[i])){    
                    return false; //有一个没有返回false
                }
            }
            return true;
        }
    };
}
```
### 图
任何二元关系都可以用图来表示。
##### 图的表示
```
邻接表由图中每个顶点的相邻顶点列表所组成。我们可以用数组，链表，甚至是散列表或是字典来表示相邻顶点列表
function Graph() {
    var vertices = []; //存储图中所有的顶点名字
    var adjList = new Dictionary();//用之前的一个字典来存储邻接表
    this.addVertex = function(v){ //添加顶点
        vertices.push(v);
        adjList.set(v, []); //顶点为键，字典值为空数组
    };
    this.addEdge = function(v, w){ //添加边
        adjList.get(v).push(w); //基于有向图
        adjList.get(w).push(v); //基于无向图
    };
    this.toString = function(){
        var s = '';
        for (var i=0; i<vertices.length; i++){
            s += vertices[i] + ' -> ';
            var neighbors = adjList.get(vertices[i]);
            for (var j=0; j<neighbors.length; j++){
                s += neighbors[j] + ' ';
            }
            s += '\n';
        }
        return s;
    };
    var initializeColor = function(){
        var color = [];
        for (var i=0; i<vertices.length; i++){
            color[vertices[i]] = 'white';
        }
        return color;
    };
}  
//测试
var graph = new Graph();
var myVertices = ['A','B','C','D','E','F','G','H','I'];
for (var i=0; i<myVertices.length; i++){
    graph.addVertex(myVertices[i]);
}
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('A', 'D');
graph.addEdge('C', 'D');
graph.addEdge('C', 'G');
graph.addEdge('D', 'G');
graph.addEdge('D', 'H');
graph.addEdge('B', 'E');
graph.addEdge('B', 'F');
graph.addEdge('E', 'I');
console.log(graph.toString());
结果如下：
A -> B C D 
B -> A E F 
C -> A D G 
D -> A C G H 
E -> B I 
F -> B 
G -> C D 
H -> D 
I -> E 

```


##### 图的遍历
图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对应每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。

为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。当要标注已经访问过的顶点时，我们用三种颜色来反映它们的状态：

白色：表示该顶点还没有被访问。
灰色：表示该顶点被访问过，但并未被探索过。
黑色：表示该顶点被访问过且被完全搜索过。

###### 广度优先搜索
广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。以下是从顶点v开始的广度优先搜索算法所遵循的步骤。

（1）创建一个队列Q。
（2）将v标注为被发现的（灰色），并将v入队列Q。
（3）如果Q非空，则运行以下步骤：
（a）将u从Q中出队列；
（b）将标注u为被发现的（灰色）；
（c）将u所有未被访问过的邻点（白色）入队列；
（d）将u标注为已被探索的（黑色）；

```
var initializeColor = function(){
      var color = [];
      for (var i=0; i<vertices.length; i++){
          color[vertices[i]] = 'white'; //初始化所有的顶点都是白色
      }
      return color;
  };
  this.bfs = function(v, callback){
      var color = initializeColor(),
          queue = new Queue(); //创建一个队列
      queue.enqueue(v); //入队列
      while (!queue.isEmpty()){
          var u = queue.dequeue(), //出队列
              neighbors = adjList.get(u); //邻接表
          color[u] = 'grey'; //发现了但还未完成对其的搜素
          for (var i=0; i<neighbors.length; i++){
              var w = neighbors[i]; //顶点名
              if (color[w] === 'white'){
                  color[w] = 'grey'; //发现了它
                  queue.enqueue(w); //入队列循环
              }
          }
          color[u] = 'black'; //已搜索过
          if (callback) {
              callback(u);
          }
      }
  };
      //测试如下：
     function printNode(value){
         console.log('Visited vertex: ' + value);
     }
     graph.bfs(myVertices[0], printNode);
     结果如下：
     Visited vertex: A
     Visited vertex: B
     Visited vertex: C
     Visited vertex: D
     Visited vertex: E
     Visited vertex: F
     Visited vertex: G
     Visited vertex: H
     Visited vertex: I

```
###### 深度优先搜索（BFS）
深度优先搜索算法将会是从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。深度优先搜索算法不需要一个源顶点。要访问顶点v，照如下的步骤做：

（1）标注v为被发现的（灰色）。
（2）对应v的所有未访问的邻点w。
（a）访问顶点w。
（3）标注v为已被探索的（黑色）。
如你所见，深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈）。

```
this.dfs = function(callback){
    var color = initializeColor(); //前面的颜色数组
    for (var i=0; i<vertices.length; i++){
        if (color[vertices[i]] === 'white'){
            dfsVisit(vertices[i], color, callback); //递归调用未被访问过的顶点
        }
    }
};
var dfsVisit = function(u, color, callback){
    color[u] = 'grey';
    if (callback) {
        callback(u);
    }
    var neighbors = adjList.get(u); //邻接表
    for (var i=0; i<neighbors.length; i++){
        var w = neighbors[i];
        if (color[w] === 'white'){
            dfsVisit(w, color, callback); //添加顶点w入栈
        }
    }
    color[u] = 'black';
};
//测试如下：
function printNode(value){
   console.log('Visited vertex: ' + value);
}
graph.dfs(printNode);
结果如下：
Visited vertex: A
Visited vertex: B
Visited vertex: E
Visited vertex: I
Visited vertex: F
Visited vertex: C
Visited vertex: D
Visited vertex: G
Visited vertex: H
```
# 斐波那契

```
最简单的做法：递归。
function fibonacci(n){

if (n <= 0) {
    return 0;
}
if (n == 0) {
    return 1;
}
return fibonacci(n-1) + fibonacci(n-2);
```
# 验证一个数是否是素数

```
if (num === 2 || num === 3) {
    return true;
};
if (num % 2 === 0) {
    return false;
};
let divisor = 3,limit = Math.sqrt(num);
while(limit >= divisor){
    if (num % divisor === 0) {
        return false;
    }
    else {
        divisor += 2;
    }
}
return true;
```
# 求最大公约数

```
let divisor = 2,res = 1;
if (a < 2 || b < 2) {
    return 1;
};
while(a >= divisor && b >= divisor){
    if (a%divisor === 0 && b%divisor === 0) {
        res = divisor;
    }
    divisor++;
}
return res;
```
# 判断数组中是否有两数之和

```
在一个未排序的数组中找出是否有任意两数之和等于给定的数。
给出一个数组[6,4,3,2,1,7]和一个数9，判断数组里是否有任意两数之和为9。
function sumFind(arr,num){

    if (!arr || arr.length < 2) {
        return;
    };
    let differ = {};
    for(let i = 0; i < arr.length; i++){
        let subStract = num - arr[i];
        if (differ[subStract]) {
            return true;
        }
        else{
            differ[arr[i]] = true;
        }
    }
    return false;
}
```
# 连字符转成驼峰
如：get-element-by-id 转为 getElementById

```
let str = 'get-element-by-id';
let arr = str.split('-');
for(let i=1; i<arr.length; i++){
arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
}
```
# 加油站问题-贪心算法
一辆汽车加满油后可行驶n公里。旅途中有若干个加油站。设计一个有效算法，指出应在哪些加油站停靠加油，使沿途加油次数最少。对于给定的n(n <= 5000)和k(k <= 1000)个加油站位置，编程计算最少加油次数。并证明算法能产生一个最优解。
要求：

输入：第一行有2个正整数n和k，表示汽车加满油后可行驶n公里，且旅途中有k个加油站。接下来的1 行中，有k+1 个整数，表示第k个加油站与第k-1 个加油站之间的距离。第0 个加油站表示出发地，汽车已加满油。第k+1 个加油站表示目的地。

输出：输出编程计算出的最少加油次数。如果无法到达目的地，则输出”NoSolution”。

function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组


```
function greedy(n, k, arr){ // n:加满可以行驶的公里数; k:加油站数量; arr:每个加油站之间的距离数组

if (n == 0 || k == 0 || arr.length == 0 || arr[0] > n) {
    return "No Solution!";  // arr[0] > n ：如果第一个加油站距离太远，也无法到达
};
let res = 0, distance = 0;  // res：加油次数；distance：已行驶距离
for(let i = 0; i <= k; i++){
    distance += arr[i];
    if (distance > n) {  // 已行驶距离 > 加满可以行驶的公里数
        if(arr[i] > n){  // 如果目前加油站和前一个加油站的距离 > 加满可以行驶的公里数，则无法到达
            return "No Solution!";
        };
        // 可以在上一个加油站加油，行驶到目前的加油站i：
        distance = arr[i];
        res++;  // 加油次数+1
    }
}
return res;
}
let arr = [1,2,3,4,5,1,6,6];
console.log(greedy(7,7,arr)) // 4
```
# 用正则实现trim() 清除字符串两端空格

```
String.prototype.trim1 = function(){

// return this.replace(/\s*/g,"");  // 清除所有空格
return this.replace(/(^\s*)|(\s*$)/g,"");  // 清除字符串前后的空格
```
# 将数字12345678转化成RMB形式：12,345,678
思路：将字符串切割成数组再反转，遍历数组，加入辅助数组，当数组长度为3的倍数，再向辅助数组加入 ","。

```
function RMB(str){

    let arr = str.split("").reverse();
    let res = [];
    for(let i = 0; i < arr.length; i++){
        res.push(arr[i]);
        if ((i + 1) % 3 === 0) {
            res.push(",");
        }
    }
    return res.reverse().join("");
}
```
# 删除相邻相同的字符串

```
function delSrt(str){

    let res = [], nowStr;
    for(let i = 0; i < str.length; i ++){
        if (str.charAt(i) != nowStr) {
            res.push(str.charAt(i));
            nowStr = str.charAt(i);
        }
    }
    return res.join("");
}
console.log(delSrt("aabcc11"))
```
# 宣讲会安排
一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(数组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。
步骤：
```
先按照会议的end时间升序排序；
排除了因为正在进行会议而无法进行的会议（now > obj[i].start）；
会议能举行，则 res++，并且更新目前时间now （now = obj[i].end;）。
```

```
function getMostCount(obj){

if (!obj || obj.length < 1) {
    return;
};
obj.sort(sortEndTime);
let res = 1, now = obj[0].end;
for(let i = 1; i < obj.length; i++){
    if (now < obj[i].start) {
        res++;
        now = obj[i].end;
    }
}
return res;
}
```
# 母牛生母牛问题
母牛每年生一只母牛，新出生的母牛成长三年后也能每年生一只母牛，假设不会死。求N年后，母牛的数量。
思路：
因为新生的母牛，只有等到第四年才能生小母牛。所以前4年，只有原来的一头母牛每年生一头。
第五年以后，除了有前一年的牛数量，还有三年前的牛可以生新的小牛。（最近3年内生的牛还不能生）

```
function cow(n){
    if (n < 1) {
        return;
    };
    let count = 0;
    if (n > 4) {
        count = cow(n-1) + cow(n-3);
    } else{
        count = n;
    }
    return count;
}
```
# 将关系型数组转换成树形结构

```
[{
    id: 1,
    name: '1',
}, {
    id: 2,
    name: '1-1',
    parentId: 1
}, {
    id: 3,
    name: '1-1-1',
    parentId: 2
}, {
    id: 4,
    name: '1-2',
    parentId: 1
}, {
    id: 5,
    name: '1-2-2',
    parentId: 4
}, {
    id: 6,
    name: '1-1-1-1',
    parentId: 3
}, {
    id: 7,
    name: '2',
}]
function translateDataToTree(data) {
  let parents = data.filter(value => value.parentId == 'undefined' || value.parentId == null)
  let children = data.filter(value => value.parentId !== 'undefined' && value.parentId != null)
  let translator = (parents, children) => {
    parents.forEach((parent) => {
      children.forEach((current, index) => {
        if (current.parentId === parent.id) {
          let temp = JSON.parse(JSON.stringify(children))
          //让当前子节点从temp中移除，temp作为新的子节点数据，这里是为了让递归时，子节点的遍历次数更少，如果父子关系的层级越多，越有利
          temp.splice(index, 1)
          //让当前子节点作为唯一的父节点，去递归查找其对应的子节点
          translator([current], temp)
          //把找到子节点放入父节点的children属性中
          typeof parent.children !== 'undefined' ? parent.children.push(current) : parent.children = [current]
        }
      }
      )
    }
    )
  }
 
  translator(parents, children)
 
  return parents
}
```
# 在两个字符串中找到最大的子字符串

```
function findSunStr(s1,s2){
    var s=sstr='',L1=s1.length;L2=s2.length;
    if(L1>L2){
        var s3=s1;
        s1=s2;
        s2=s3;
        L1=s2.length;
    }
    for(var j=L1;j>0;j--){
        for(var i=0;i<L1-j;i++){
            sstr=s1.subStr(i,j);
            if(s2.indexof(sstr)>=0){
                return sstr;
            }
            return '';
        }
    }
}
```
# 版本号排序
1.45.0>1.5.0

```
const version = ['1.45.0', '1.5', '6', '3.3.3.3.3']
//直接用sort函数比较是不行的，sort函数在比较字符串的时候，是比较字符串的Unicode进行排序的
//const version = ['1.45.0', '1.5', '6', '3.3.3.3.3'];
//const temp = [[1, 45, 0], [1, 5], [6], [3, 3, 3]]
//const a = [1, 45, 0],b = [1, 5];
//a[k]去比较b[k],比较只要能比较出大小（不等）就结束这一层循环，如果相等就继续
//a[k] > b[k]是我们要交换位置的条件，这时候要结束内层循环，但是a[k] < b[k]同样要结束循环，只不过不交换位置

使用选择排序
const chooseSort = arr = > {
  for (let i = 0; i < arr.length; i++) {
    // 选定首位为最小值
    let minIndex = i;
    for (let j = i; j < arr.length; j++) {
      // 比较时如果当前项更小，增更新最小值序号
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    // 将最小值排到这一轮循环的首位
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
  }
  return arr;
};

最终结果
// 使用的是选择排序
const versionSort = version => {
  const temp = version.map(v => v.split('.'));
  for (let i = 0; i < temp.length; i++) {
    let minIndex = i;
    for (let j = i; j < temp.length; j++) {
      for (let k = 0; k < temp[j].length; k++) {
        const current = +temp[j][k],
        min = +temp[minIndex][k];
        if (current < min) {
          minIndex = j;
        }
        // 只要不等，就立刻结束最内层遍历！
        if (current !== min) {
          break
        }
      }
    }
    [temp[i], temp[minIndex]] = [temp[minIndex], temp[i]];
  }
  return temp.map(v = > v.join('.'))
};

const version1 = ['1.45.0', '1.5', '6', '3.3.3.3.3'];
console.log(versionSort(version1));
// ["1.5", "1.45.0", "3.3.3.3.3", "6"]

const version2 = ['0.1.1', '2.3.3', '0.3002.1', '4.2', '4.3.5', '4.3.4.5'];
console.log(versionSort(version2));
// ["0.1.1", "0.3002.1", "2.3.3", "4.2", "4.3.4.5", "4.3.5"]
```
