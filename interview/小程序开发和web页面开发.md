# 小程序出现的原因
webview通过调用js-sdk调用一些普通网页不能完成的系统功能，虽然js-sdk虽然解决了移动网页能力不足的问题，但其并没有解决使用移动网页遇到的不良体验问题。因为**受限于设备性能和网络速度出现的白屏问题**，于是出现了增强版本的JS-SDK，其中有一个重要功能，称之为“**微信web资源离线存储**”。但是 离线存储 能够解决了一些问题，但是对于**一些复杂的页面依然会有白屏的问题，例如页面加载了大量的 CSS 或者是 JavaScript 文件，这些文件的执行时间占用了大量的 UI 线程，这种时候，即使通过离线存储快速的加载资源，但是依旧会有页面的白屏现象**。除了白屏，影响 Web 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。**对于一些有经验的 Web开发者而言，会使用一些 SPA 的框架，来模拟客户端原生的页面切换过渡。**通常的方式是在一个 WebView 中去模拟多个页面，通过 CSS 处理，加之精细化的脚本代码做到点击反馈和页面切换，获得较好的体验。然而并不是所有的开发者都有足够的时间和精力来使得页面的体验变得出色。

[微信官方解释](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0006a2289c8bb0bb0086ee8c056c0a)
我们在对小程序的架构设计时的要求只有一个，就是要快，包括要渲染快、加载快等。当用户点开某个小程序时，我们期望体验到的是只有很短暂的加载界面，在一个过渡动画之后可以马上看到小程序的主界面。

我们首先需要确定用什么技术来渲染小程序界面，这是跟开发者的学习门槛息息相关的。

一般来说，渲染界面的技术有三种：

用纯客户端原生技术来渲染
用纯 Web 技术来渲染
介于客户端原生技术与 Web 技术之间的，互相结合各自特点的技术（下面统称 Hybrid 技术）来渲染

由于小程序的宿主是微信，所以我们不太可能用纯客户端原生技术来编写小程序 。如果这么做，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。因此，我们需要像Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。

但是，如果我们用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题，这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。

按照上面的讨论，使用纯客户端原生技术或纯 Web 技术都有各自的缺点，那如果使用两者结合起来的 Hybrid 技术来渲染小程序，能否优于各自独立渲染的技术方案呢？实际上，这种 Hybrid 技术在业界过去几年里演化过数种技术方案，典型的如早期的PhoneGap[1]，还有近两年流行的React Native[2]（下称 RN），还有像微信网页里的 JS-SDK[3] 这种轻量级的应用。

从渲染底层来看，PhoneGap与微信 JS-SDK 是类似的，它们最终都还是使用浏览器内核来渲染界面。而 RN 则不同，虽然是用 Web 相关技术来编写，同样是利用了 JavaScript 解释执行的特性，但 RN 在渲染底层是用客户端原生渲染的。实际上，小程序最初选型时 RN 是候选之一，虽然说 RN 是结合了 React 框架的代码组成方式，但是我们完全可以剥离React 框架这套写法，定义出更符合小程序特点的代码组成方式。不过，最终我们并没有选择这种类 RN 技术，原因有三：

RN 所支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求，而对 RN 的改造具有不小的成本和风险。
RN 现有能力下还存在的一些不稳定问题，比如性能、Bug等。RN 是把渲染工作全都交由客户端原生渲染，实际上一些简单的界面元素使用 Web 技术渲染完全能胜任，并且非常稳定。
RN 存在一些不可预期的因素，比如近期就出现了许可协议问题。

最终，我们选择类似于微信 JSSDK 这样的 Hybrid 技术，即界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。此外，界面渲染这一块我们定义了一套内置组件以统一体验，并且提供一些基础和通用的能力，进一步降低开发者的学习门槛。值得一提的是，内置组件有一部分较复杂组件是用客户端原生渲染的，以提供更好的性能
# 小程序开发和web网页开发的区别

第一个区别就是单线程和双线程的区别

* 网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应
* 小程序中，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本，这样可以提高效率。小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。

第二个区别 网页没有操作系统的api 但是小程序有操作系统的api和系统原生控件

* 小程序定义了很多api和原生进行通信，提高性能。
* 小程序里面可以嵌入了部分原生控件提升性能。

第三个区别

* PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。
* 小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端的不同的代码运行环境


# 小程序的双线程机制

小程序分为视图层和逻辑层，视图层的相关任务全都在WebView里执行。一个小程序存在多个界面，所以视图层存在多个WebView线程。而逻辑层采用JsCore线程运行JS脚本。他们之间通过系统层的WeixinJsBridge进行通信，也就是逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。在渲染层把 WXML 转化成对应的 JS 对象。在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

[图片链接](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65688db20c4e415aac7bc63e1c0308fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

逻辑层的JS代码全部载入到一个Webview里面，称之为AppService，整个小程序仅仅有一个，而且整个生命周期常驻内存；而全部的视图（wxml和wxss）都是单独的Webview来承载，称之为AppView。我们在渲染层的请求并不会直接到了逻辑层，而是会先到了系统层。在系统层先进行操作处理一部分功能再将数据传递给逻辑层，逻辑层也一样。 所以不能频繁进行setdata请求绑定交互。如果当前数据并不会在页面中进行显示，数据也不应该定义在data中，否则每次在进行数据绑定时，这些数据也会进行一次从数据层到逻辑层的传递，占用了系统层的资源。

[原文链接](https://juejin.cn/post/7035089295199174664)
[原文链接]（https://developers.weixin.qq.com/community/develop/article/doc/0000461093c4d8782ff7cf7d95b413）