# 垃圾回收机制


1. 栈当中的内存是如何回收的

js引擎是通过移动ESP指针来销毁函数保存在栈当中的执行上下文的



2. 堆中的数据是如何回收的



# 代际假说 和 分代收集
  代际假说：
   1. 大部分对象在内存中存在的时间很短，对象一经分配内存，很快就会变得不可访问
   2. 不死的对象，会活的更久


# 新生代区域     老生代区域
新生代：
  - 存放生存时间短的对象
  - 1~8M
  - 副垃圾回收器


老生代：
 - 存放生存时间长的对象
 - 主垃圾回收器


# 垃圾回收器的流程
1. 标记空间中活动对象 和 非活动对象
2. 回收 非活动对象 所占据的内存
3. 内存整理（将内存碎片整理成连续的内存空间）




# 副垃圾回收器 （Scavenge算法）
1. 新对象进入 对象区域
2. 对象区域快要存满时进行垃圾回收
3. 对象区域中剩余的对象转移到空闲区域
4. 两个区域对调

 - 对象晋升策略
 经过两次垃圾回收还存活的对象，会被移入老生代区




# 主垃圾回收器 （标记-清除 Mark-Sweep算法）
1. 递归的遍历一组根元素
2. 清除垃圾数据
3. 整理


# 全停顿
js是运行在主线程上的，一旦垃圾回收生效，js脚本就会暂停执行，等到垃圾回收完成，再继续执行