[原文链接](https://mp.weixin.qq.com/s/ezx1S3-ay22LwoL7pnJeyw)
# 性能优化的目的

* 保证资源更快的 加载速度：达到越快渲染越快，视图展现就越快。
* 保证视图更快的 渲染速度/交互速度：用户与页面交互，前提是页面要渲染出来，其次是页面需要尽早反馈，目的就是保证用户良好的体验性。

# 优化角度也是 从输入 URL 到页面加载完成发生了什么 开始优化

* 进行 DNS 解析
* 建立 TCP 连接
* 客户端发送 HTTP 请求
* 服务端响应 HTTP 资源
* 浏览器获取响应内容，进行解析和渲染
  
根据整个过程对这个过程中的各个指标进行优化

（一）首先是 第一字节时间 TTFB 如何优化

1.建立CDN链接
2.拆分核心接口和非核心接口
3.后端优化接口返回，缩短查询数据库时间和上下游链路时间
4.避免多次重定向
5.启用 HSTS 不仅仅可以有效防范中间人攻击。为浏览器节省来一次 302/301 的跳转请求。
6.启用DNS-prefetch
7.preload/prefetch
8.使用 HTTP/2 or HTTP/3

（一）首次内容绘制 FCP
1.消除阻塞渲染的资源 css尽量放到头部加载，JS尽量使用async/defer加载 async加载完就执行 defer都加载完按顺序执行。
2.拆分css和js 延迟加载非必要的css和js
3.缩小js和css代码的体积
4.tree-shaking splitchunks entry 动态import

（二）最大内容绘制 LCP
1.使用webp格式图片，图片加载失败重新加载
2.核心内容的接口和非核心内容的接口分开

（三）首次输入延迟FID
1. 减少第三方代码的影响
2. 减少 JavaScript 执行时间
    * 分割长任务
    * 优化您的页面，做好交互准备
    * 使用 Web Worker
    * 减少 JavaScript 执行时间
3. 最小化主线程工作
4. 保持较低的请求数和较小的传输大小

时间角度优化：减少耗时  空间角度优化：降低资源占用

1. 网络请求优化
   (1)、请求链路：DNS 查询、部署 CDN 节点、缓存等。dns-prefetch
                使用 HTTP/2、HTTP/3，提升资源请求速度 长链接 解决请求头阻塞
                对请求进行优化，比如对多个请求进行合并，减少通信次数
                将主要请求和耗时长的请求拆分，将主要请求和不主要请求拆分。
                对请求进行域名拆分，提升并发请求数量
                合理地使用 CDN 资源，有效地减少网络请求耗时。
                ssr渲染、减少dom数量
                合理的利用缓存，webpack生成chunk的hash缓存值、还有http服务的缓存时间
                对请求资源进行缓存，包括但不限于使用浏览器缓存、HTTP 缓存、后台缓存，比如使用 Service Worker、PWA 等技术
   (2)、数据大小：代码大小、图片资源等。
                代码大小：(1) 合理的对资源进行分包。(2) 移除不需要的代码。(3) 资源压缩和合并。
                        图片，js，css 压缩和拆分，
                        js拆包懒加载，js异步(defer,async加载)
                        css媒体查询加载，减少css体积使用原子类样式
                        图片使用雪碧图和webp、jpg等压缩模式
                        使用webpack拆分代码，首先是多入口分包、公共文件拆分、treeshaking、不常变化的js不打包放到cdn加载
2. 首屏加载优化
   将页面内容尽快地展示给用户，减少页面白屏时间。将用户可操作的时间尽量提前，避免用户无法操作的卡顿体验。
    (1)、对页面的内容进行分片/分屏加载
    (2)、仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源
    (3)、使用骨架屏进行预渲染
    (4)、使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块
    (5)、使用服务端直出渲染，减少页面二次请求和渲染的耗时
3. 渲染过程优化
    (1)、减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时
    (2)、减少重排和重绘
    (3)、通过合理使用浏览器 GPU 能力，提升浏览器渲染效率
4. 计算/逻辑运行提速
    (1)、通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况
    (2)、将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker
    (3)、通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly
    (4)、通过将计算结果缓存的方式，减少运算次数



# 性能指标 RAIL 模型
Google 为前端页面性能的评估提出了 RAIL 模型，核心内容如下：

## Response 响应 
   * 标准 输入延迟时间(从点到绘制)小于100ms
   * 一般指的是用户输入网页快速给出结果的过程，比如点击按钮，切换表单，启动动画之类的。
## Animation 动画 
   * 标准 每个帧的工作(从JS到绘制)完成时间小于16ms 
   * 指的是涉及style，layout，paint，composite过程的行为。比如：用户滚动页面，拖动刷新，页面动画等。用户滚动页面、拖动手指（打开菜单）或看到动画、拖动时，应用的响应与手指位置有关、拉动刷新、滑动轮播，此指标仅适用于拖动的持续阶段，不适用于开始阶段。
## Idle 空闲
   * 标准 主线程JS工作分成不大于50ms的块
   * 用户没有和页面交互，但主线程应足够用于处理下一个用户输入
## Load 加载
   * 页面可以在1000ms内就绪，用户加载页面并看到关键路径内容

# 用户对于网站延迟的反应

0-16ms：动画的一帧渲染不大于16ms时，用户会感觉动画是流畅的。
0-100ms：当用户进行操作时，100ms内窗口响应用户操作，用户会有一种立即获得结果的感觉。
100-300ms：用户可能微微察觉到一点延迟。
300-1000ms：此时长范围是用户能接受的页面的加载或者视图的改变所用时长。
1000+ms:用户的注意力将离开正在执行的任务。
10000+ms:用户已经没有耐心等待下去。

# 如何做性能优化

1、性能优化需要分析方法和技术原理相结合，web和小程序的底层原理不同，性能优化技术方案也不同，因此我们需要搞清楚背后的技术原理。
2、我们需要借助分析方法弄清楚我们的系统当下存在着什么样的问题，才能用技术方案去解决。

性能优化方式方法

1、线下有Network中的performance面板和Timings视图、Lighthouse、小程序开发者体验评分工具
2、线上webpagetest

# 性能指标
常用的指标就是：​白屏​，​首屏​，​domready​,​pageloaded​四个指标，在通常的index.html中，我们通过性能API获取到响应的指标值。
[原文链接](http://e.betheme.net/article/show-54375.html?action=onClick)
## 白屏

一般认为浏览器开始渲染<body>标签或者解析完<head>标签的时刻就是页面白屏结束的时间点。

白屏开始时间相当于performance.timing.navigationStart

白屏结束时间相当于performance.timing.responseStart

## 首屏

首屏是指用户看到的第一屏，就是网页当前窗口的区域完整显示的时间。

首屏内容加载最慢的就是图片资源，在DOM树构建完成后将会去遍历首屏内所有图片标签，并监听所有图片的onload事件，最终遍历图片标签的加载时间的最大值，用这个最大值减去navigationStart可获取近似的首屏时间。

首屏时间相当于最后一张图片加载的时间减去navigationStart时间

## DOM Ready
指浏览器开始对基础页文件内容进行解析到文本中构建出一个内部数据结构（DOM树）的时间。

DOM渲染完成时间是DOMContentLoaded事件监听的，

所以它的结束时间相当于performance.timing.domContentLoadedEventEnd。

## Page Loaded

整页加载完成时间，该结束时间通过window.onload()进行采集。

Page Loaded结束时间相当于performance.timing.loadEventEnd。

## 首次绘制（First Paint，FP）
在渲染进程确认要渲染当前响应资源后，渲染进程会先创建一个空白页面，通常把创建空白页面的这个时间点称为 First Paint，简称 FP
所谓的 白屏时间 其实指的就是创建这个空白页面到浏览器开始渲染非空白内容的时间，比如页面背景发生变化等
## 首次内容绘制（First Contentful Paint，FCP）
当用户看见一些 "内容" 元素被绘制在页面上的时间点，和白屏是不一样，它可以是 文本 首次绘制，或 SVG 首次出现，或 Canvas 首次绘制等，即当页面中绘制了第一个 像素 时，这个时间点称为 First Content Paint，简称 FCP
## 首屏时间 / 最大内容绘制（Largest Contentful Paint, LCP）
LCP 是一种新的性能度量标准，LCP 侧重于用户体验的性能度量标准，与现有度量标准相比，更容易理解与推理，当首屏内容完全绘制完成时，这个时间点称为 Largest Content Paint，简称 LCP
最大内容绘制应在 2.5s 内完成
## 首次输入延迟（First Input Delay, FID）
FID 测量的是当用户第一次在页面上交互的时候（点击链接、点击按钮 或 自定义基于 js 的事件），到浏览器实际开始处理这个事件的时间
首次输入延迟应在 100ms 内完成
## 累积布局偏移（Cumulative Layout Shift, CLS)
CLS 是为了测量 视觉稳定性，以便提供良好的用户体验
累积布局偏移应保持在 0.1 或更少
首字节达到时间（Time to First Byte，TTFB）
指的是浏览器开始收到服务器响应数据的时间（后台处理时间 + 重定向时间），是反映服务端响应速度的重要指标
TTFB 时间如果超过 500ms，用户在打开网页的时就会感觉到明显的等待

[各个阶段指标示意图](https://img-blog.csdnimg.cn/20200804203800588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xldHNTdHVkeQ==,size_16,color_FFFFFF,t_70)

# 一些指标计算(performance.timing的计算方式 高版本已放弃)

[指标图](https://img-blog.csdnimg.cn/20200804204106817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xldHNTdHVkeQ==,size_16,color_FFFFFF,t_70)

unload	前一个页面卸载耗时	unloadEventEnd - unloadEventStart	前一个页面卸载时可能监听了 unload 做些数据收集，会影响页面跳转

redirect	重定向耗时	redirectEnd - redirectStart	过多重定向影响性能

appCache	缓存耗时	domainLookupStart - fetchStart	

dns	DNS 解析耗时	domainLookupEnd - domainLookupStart	

tcp	TCP 连接耗时	connectEnd - connectStart	 

ssl	SSL 安全连接耗时	connectEnd - secureConnectionStart	只在 HTTPS 下有效

ttfb	Time to First Byte（TTFB），网络请求耗时	responseStart - requestStart	

response	数据传输耗时	responseEnd - responseStart	 

dom	可交互 DOM 解析耗时	domInteractive - responseEnd	Interactive content

dom2	剩余 DOM 解析耗时	domContentLoadedEventStart - domInteractive	DOMContentLoaded 所有DOM元素都加载完毕(除了 async script)

DCL	DOMContentLoaded 事件耗时	domContentLoadedEventEnd - domContentLoadedEventStart	document.addEventListener('DOMContentLoaded', cb)

resources	资源加载耗时	loadEventStart - domContentLoadedEventEnd	完整DOM(DOMContentLoaded)到资源加载完毕(window.onLoad)时间

onLoad	onLoad事件耗时	loadEventEnd - loadEventStart	 

firstbyte	首包时间	responseStart - domainLookupStart	 

fpt	First Paint Time, 首次渲染时间 / 白屏时间	responseStart - navigationStart	从请求开始到浏览器开始解析第一批 HTML 文档字节的时间差

tti	Time to Interact，首次可交互时间	domInteractive - navigationStart	浏览器完成所有 HTML 解析并且完成 DOM 构建，此时浏览器开始加载资源

ready	HTML 加载完成时间， 即 DOM Ready 时间	domContentLoadedEventEnd - navigationStart	如果页面有同步执行的 JS，则同步 JS 执行时间 = ready - tti

load	页面完全加载时间	loadEventEnd - navigationStart	load = 首次渲染时间 + DOM 解析耗时 + 同步 JS 执行 + 资源加载耗时

navigationStart 表示从上一个文档卸载结束时的unix时间戳，如果没有上一个文档，则与fetchStart一致

unloadEventStart 表示前一个网页（与当前页面同域）unload的时间戳，如果无前一个网页unload或者前一个网页与当前页面不同域，则值为0

unloadEventEnd 返回前一个页面unload事件绑定的回调函数执行完毕的时间戳

redirectStart 重定向开始的时间戳，同域内才算，否则为0

redirectEnd 重定向结束的时间戳，同域内才算，否则为0

fetchStart 浏览器准备使用http请求抓取文档的时间戳，这发生在检查本地缓存之前

domaInLookupStart/domaInLookupEnd DNS域名查询开始/结束时间，如果使用了本地缓存（无DNS查询）或持久链接，则与fetchStart值相等

connectStart TCP开始建立连接的时间戳，如果是持久链接，则与fetchStart值一致

connectEnd TCP完成握手的时间戳，如果是持久链接，则与fetchStart值一致

secureConnectionStart HTTPS链接开始的时间，如果不是安全链接，值为0

requestStart HTTP请求开始时间，包括从本地读取缓存

responseStart HTTP开始接收响应的时间(获取到第一个字节)，包括从本地读取缓存

responseEnd HTTP接收响应完成的时间（获取到最后一个字节），包括从本地读取缓存

domLoading 开始解析DOM树的时间，此时Document.readyState变为loading，抛出readystatechange事件

domInteractive 完成解析DOM树的时间，此时Document.readyState变为interactive，此时并没有加载资源,抛出readystatechange事件

domContentLoadEventStart DOM树解析完成后，网页资源开始加载的时间，在domContentLoaded事件抛出前发生

domContentLoadEventEnd DOM树解析完成后，网页资源加载完成的时间

domComplete DOM树解析完成后，资源准备就绪的时间，此时Document.readyState变为complete，抛出readystatechange事件

loadEventStart load事件开始时间

loadEventEnd load事件结束时间，网页加载完成

# 性能监控
[性能监控搭建](https://juejin.cn/post/7097157902862909471#heading-24)
* 页面的性能情况：包括各阶段加载耗时，一些关键性的用户体验指标等
* 用户的行为情况：包括PV、UV、访问来路，路由跳转等
* 接口的调用情况：通过http访问的外部接口的成功率、耗时情况等
* 页面的稳定情况：各种前端异常等
* 数据上报及优化：如何将监控捕获到的数据优雅的上报

[PerformanceObserver](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver)

[监控的各个指标---PerformanceTiming](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e2b5e8f9ac24e5f90eedd48074dbc0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

# ​performance.getEntriesByType('navigation') 和 performance.timing

优先使用：​performance.getEntriesByType('navigation')[0]​，以下简称 ​navigation​
不可用时降级处理：​performance.timing​，简述 ​timing​
timing 时间属性是以类似 Date.now() 这样的时间戳标识，
navigation 是每个页面都从 0 开始计时，精度也更高。
timing 是 navigationStart 开始，navigation 是以 startTime 开始。
timing 和 navigationStart 都被新的标准废弃，但兼容较高。
navigation 新增了 资源大小 和 serverTiming，可以分析资源是否压缩、是否过大过小 和 离线应用处理时间。

# 重要指标以及如何优化
[web.dev网站对于这个网站指标的优化](https://web.dev/fcp/)

## TTI 从页面开始加载到其主要子资源已加载的时间，并且能够可靠地快速响应用户输入。
从(FCP)首次内容绘制开始，向前搜索5秒，没有长任务，且不能超过2个get请求，向后搜索最后一个长任务，如果没有长任务被发现就到FCP停止。TTI的时间是最后一个长任务的时间，如果没有长任务的话，则等于FCP时间。

引入tti-polyfill.js(可通过npm包获取)，获取到tti值
```
import ttiPolyfill from './path/to/tti-polyfill.js';
ttiPolyfill.getFirstConsistentlyInteractive().then((tti) => {...
});
```
测量长任务（https://developer.mozilla.org/zh-CN/docs/Web/API/Long_Tasks_API）
```
var observer = new PerformanceObserver(function(list) {
    var perfEntries = list.getEntries();
    for (var i = 0; i < perfEntries.length; i++) {
        // Process long task notifications:
        // report back for analytics and monitoring
        // ...
    }
});
// register observer for long task notifications
observer.observe({entryTypes: ["longtask"]});
// Long script execution after this will result in queueing
// and receiving "longtask" entries in the observer.

```

## 第一字节时间 TTFB
衡量对资源的请求和响应的第一个字节开始和到达之间时间的指标。
```
new PerformanceObserver((entryList) => {
  const [pageNav] = entryList.getEntriesByType('navigation');

  console.log(`TTFB: ${pageNav.responseStart}`);
}).observe({
  type: 'navigation',
  buffered: true
});
```
优化点

* 托管服务商的基础设施能力不足，无法处理高流量负载
* 网络服务器的内存不足，可能导致 系统颠簸
* 未经优化的数据库
* 不良的数据库服务器配置
* 避免多次重定向.
* 提前向跨域资源源建立连接 Preconnect 。
* 将源提交给HSTS预加载列表，以消除 HTTP-HTTPS 重定向延迟。
* 使用 HTTP/2 or HTTP/3。
* 考虑预测性预取，为没有指定减少数据使用偏好的用户提供快速页面导航。
* 在可能和适当的情况下，使用服务器端生成（SSG）来代替SSR的标记。

## 首次内容绘制 FCP

首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。标记浏览器渲染来自 DOM 第一位内容的时间点，对于该指标，"内容"指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。虽然部分内容已完成渲染，但并非所有内容都已经完成渲染。这是首次内容绘制 (FCP) 与*Largest Contentful Paint 最大内容绘制 (LCP)*（旨在测量页面的主要内容何时完成加载）之间的重要区别。

为了提供良好的用户体验，网站应该努力将首次内容绘制控制在 1.8 秒或以内。为了确保您能够在大部分用户的访问期间达成建议目标值，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

```
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
    console.log('FCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'paint', buffered: true});
```
### 优化点

#### 消除阻塞渲染的资源
[原文链接](https://web.dev/render-blocking-resources/)

##### 哪些 URL 被标记为渲染阻止资源

* 一个<script>标签：

是在<head>文档中。
没有defer属性。
没有async属性。


* 一个<link rel="stylesheet">标签：

没有disabled属性。当此属性存在时，浏览器不会下载样式表。

没有 media 专门匹配用户设备的属性。media="all"被认为是渲染阻塞。

##### 如何识别关键资源

您可以通过仅发送您需要的代码和样式来减小页面大小。单击 URL 以在 Sources 面板中检查该文件。CSS 文件中的样式和 JavaScript 文件中的代码用两种颜色标记：

绿色（关键）：第一次绘制所需的样式；对页面核心功能至关重要的代码。
红色（非关键​​）：适用于不立即可见的内容的样式；代码未在页面的核心功能中使用。

##### 如何消除渲染阻塞脚本

* 将同步js脚本变成异步脚本并且放到body底部，否则html会停止渲染去执行js代码。
* 删除未使用的代码
  
确定关键代码后，将该代码从阻止呈现的 URL 移动到 scriptHTML 页面中的内联标记。当页面加载时，它将拥有处理页面核心功能所需的东西。

如果阻止呈现的 URL 中有不重要的代码，您可以将其保留在 URL 中，然后使用async或defer属性标记 URL（另请参阅使用 [JavaScript 添加交互性](https://web.dev/critical-rendering-path-adding-interactivity-with-javascript/)）。


这展示了一个重要的属性：我们的脚本在它插入文档的确切位置执行。当 HTML 解析器遇到脚本标签时，它会暂停构建 DOM 的过程，并将控制权交给 JavaScript 引擎；JavaScript 引擎完成运行后，浏览器会从上次中断的地方重新开始并恢复 DOM 构建。

将 async/defer 关键字添加到 script 标签告诉浏览器在等待脚本可用时不要阻止 DOM 构建，这可以显着提高性能。

defer脚本会被延迟到整个页面都解析完毕后再运行。因此，在<script>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。defer脚本下载完了不是立即执行，而是等dom构建完了再执行。

async 与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。async脚本下载完了立即执行。

defer属性和把script放在body底部的区别是 defer是提前下载延迟执行，body底部是延迟下载延迟执行


应该删除根本不使用的代码（请参阅[删除未使用的代码](https://web.dev/remove-unused-code/)）。

1. 打开浏览器的设置，勾选停用缓存(disabled cache)
2. 打开设置旁边的三个点然后选择更多工具然后点开覆盖率(coverage) 重新加载资源看到红色是未使用的代码，绿色是使用的代码
3. 或者使用webpack-bundlize分析公共包并且拆包

[查看unusedCode](https://web-dev.imgix.net/image/admin/xlPdOMaeykJhYqGcaMJr.png?auto=format&w=1600)

##### 如何消除渲染阻塞样式表
[原文链接](https://web.dev/render-blocking-resources/)

* 延迟加载非关键 CSS
[原文链接](https://web.dev/defer-non-critical-css/)
在 HTML 页面 head 的 <style> 块中内联首次绘制所需的关键样式。然后使用 preload 链接异步加载其余样式。

<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="styles.css"></noscript>
这不是加载 CSS 的标准方式。以下是工作原理：

link rel="preload" as="style" 异步请求样式表。您可以在预加载关键资产指南中了解有关 preload 的更多信息。
link 的 onload 属性允许在加载 CSS 完成后对其进行处理。
在使用 onload 处理程序后将其“归零”有助于某些浏览器避免在切换 rel 属性时重新调用处理程序。
对 noscript 元素内的样式表的引用可作为不执行 JavaScript 的浏览器的后备。noscript标签允许在不支持script脚本的网站展示内容

* 将这些样式拆分为不同的文件，由媒体查询组织。然后为每个样式表链接添加一个媒体属性。加载页面时，浏览器仅阻止第一次绘制以检索与用户设备匹配的样式表

[拆分阻塞渲染的css](https://web.dev/critical-rendering-path-render-blocking-css/)

```
<link href="style.css" rel="stylesheet" />
<link href="print.css" rel="stylesheet" media="print" />
<link href="other.css" rel="stylesheet" media="(min-width: 40em)" />
<link href="portrait.css" rel="stylesheet" media="orientation:portrait" />
```

media="print"，这意味着该样式表中的样式只会在用户尝试打印您的网页时应用。这对于隐藏导航、评论、侧边栏等内容非常有用，以便用户可以简单地打印文本。第二个样式表声明仅在打印内容时应用——也许您想重新排列布局、更改字体等，因此此样式表声明不需要阻止呈现首次加载时的页面。

media="(min-width: 40em)" 最后的样式表声明提供了一个由浏览器执行的“媒体查询”：如果条件匹配，浏览器将阻止呈现，直到样式表被下载和处理。

第四个声明有一个动态媒体查询，它在页面加载时进行评估。根据页面加载时设备的方向，portrait.css 可能会或可能不会呈现阻塞。

###### 缩小 CSS
[原文链接](https://web.dev/unminified-css/)
语义化样式转成原子类样式
```
/* Header background should match brand colors. */
h1 {
  background-color: #000000;
}
h2 {
  background-color: #000000;
}

h1,
h2 {
  background-color: #000000;
}
```
压缩css代码
###### 移除未使用的 CSS
[原文链接](https://web.dev/unused-css-rules/)

使用浏览器分析未使用的css，拆分css

###### 预连接到所需的来源
[原文链接](https://web.dev/uses-rel-preconnect/)

通过预连接提高页面加载速度。考虑添加 preconnect 或 dns-prefetch 资源提示来建立与重要第三方源的早期连接。

preconnect 的作用是提前和第三方资源建立连接，设置了它浏览器就会做好早期的连接工作，但这个连接通常只会维持 10 s。

<link rel="preconnect"> 会通知浏览器，您的页面打算与另一个源建立连接，而且您希望该过程尽快开始。

<link rel=preconnect> Lighthouse 报告的 Opportunities 部分列出了所有尚未优先考虑获取请求的关键请求

#### 减少服务器响应时间 (TTFB)
[原文链接](https://web.dev/ttfb/) 

TTFB 是一个衡量对资源的请求和响应的第一个字节开始和到达之间时间的指标。

* Redirect time 重定向时延
* Service worker 启动时延（如果适用）
* DNS 查询时延
* 建立连接和 TLS 所消耗时延
* 请求，直到响应的第一个字节到达为止的时延

```
new PerformanceObserver((entryList) => {
  const [pageNav] = entryList.getEntriesByType('navigation');

  console.log(`TTFB: ${pageNav.responseStart}`);
}).observe({
  type: 'navigation',
  buffered: true
});
```

###### 避免多个页面重定向
[原文链接](https://web.dev/redirects/)

###### 预加载关键请求
[原文链接](https://web.dev/uses-rel-preload/)
```
<head>
  ...
  <link rel="preload" href="styles.css" as="style">
  <link rel="preload" href="ui.js" as="script">
  ...
</head>
```

###### 避免巨大的网络负载
[原文链接](https://web.dev/total-byte-weight/)
缩小和压缩网络有效负载。
图像使用 WebP 格式，而不是 JPEG 或 PNG。
将 JPEG 图像的压缩级别设为 85 。

###### 使用高效的缓存策略服务静态资产
[原文链接](https://web.dev/uses-long-cache-ttl/)
缓存/CDN缓存/service worker

##### 避免 DOM 过大
[原文链接](https://web.dev/dom-size/)

##### 最小化关键请求深度
[原文链接](https://web.dev/critical-request-chains/)
关键请求链是一系列对页面呈现很重要的依赖网络请求。链的长度越长，下载量越大，对页面加载性能的影响就越大。

#### 确保文本在网页字体加载期间保持可见
字体通常是需要一段时间才能加载的大文件。一些浏览器在字体加载之前隐藏文本，导致不可见文本 (FOIT) 闪烁。
如何避免显示不可见的文字:
避免在加载自定义字体时显示不可见文本的最简单方法是临时显示系统字体。通过包含font-display: swap在您的@font-face style
```
@font-face {
  font-family: 'Pacifico';
  font-style: normal;
  font-weight: 400;
  src: local('Pacifico Regular'), local('Pacifico-Regular'), url(https://fonts.gstatic.com/s/pacifico/v12/FwZY7-Qmy14u9lezJ-6H6MmBp0u-.woff2) format('woff2');
  font-display: swap;
}
```
font-display API指定字体的显示方式。swap告诉浏览器使用该字体的文本应该立即使用系统字体显示。自定义字体准备就绪后，它将替换系统字体。

用于<link rel="preload" as="font">更早地获取您的字体文件

#### 保持较低的请求数和较小的传输大小
[原文链接](https://web.dev/resource-summary/)
 压缩图片、合并js和css请求、字体大小
## 最大内容绘制 LCP
[原文内容](https://web.dev/lcp/)
最大内容绘制 (LCP) 是测量**感知加载速度**的一个以用户为中心的重要指标，因为该项指标会在页面的主要内容基本加载完成时，在页面加载时间轴中标记出相应的点，迅捷的 LCP 有助于让用户确信页面是有效的。

诸如load（加载）或DOMContentLoaded（DOM 内容加载完毕）这样的旧有指标并不是很好，因为这些指标不一定与用户在屏幕上看到的内容相对应。而像First Contentful Paint 首次内容绘制 (FCP)这类以用户为中心的较新性能指标只会捕获加载体验最开始的部分。如果某个页面显示的是一段启动画面或加载指示，那么这些时刻与用户的关联性并不大。我们以往推荐过一些性能指标，例如First Meaningful Paint 首次有效绘制 (FMP)。

哪些元素在考量范围内？

根据当前最大内容绘制 API 中的规定，最大内容绘制考量的元素类型为：

* <img>元素
* 内嵌在<svg>元素内的<image>元素
* <video>元素（使用封面图像）
* 通过url()函数（而非使用CSS 渐变）加载的带有背景图像的元素
* 包含文本节点或其他行内级文本元素子元素的块级元素。

报告给最大内容绘制的元素大小通常是用户在可视区域内可见的大小。如果有元素延伸到可视区域之外，或者任何元素被剪裁或包含不可见的溢出，则这些部分不计入元素大小。

```
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});
```

## 首次输入延迟 FID
[原文内容](https://web.dev/fid/)

首次输入延迟 (FID) 是测量加载响应度的一个以用户为中心的重要指标，因为该项指标将用户尝试与无响应页面进行交互时的体验进行了量化，低 FID 有助于让用户确信页面是有效的。

一般来说，发生输入延迟（又称输入延时）是因为浏览器的主线程正忙着执行其他工作，所以（还）不能响应用户。可能导致这种情况发生的一种常见原因是浏览器正忙于解析和执行由您的应用程序加载的大型 JavaScript 文件。在此过程中，浏览器不能运行任何事件侦听器，因为正在加载的 JavaScript 可能会让浏览器去执行其他工作。

如果交互没有事件侦听器怎么办？

FID 测量接收到输入事件的时间点与主线程下一次空闲的时间点之间的差值。这就意味着**即使在尚未注册事件侦听器的情况下，**FID 也会得到测量。这是因为许多用户交互的执行并不需要事件侦听器，但一定需要主线程处于空闲期。例如，在对用户交互进行响应前，以下所有 HTML 元素都需要等待主线程上正在进行的任务完成运行：

* 文本字段、复选框和单选按钮 (<input> 、 <textarea>)
* 下拉选择列表（<select>）
* 链接 (<a>)

FID 是测量页面加载期间响应度的指标。因此，FID 只关注不连续操作对应的输入事件，如点击、轻触和按键。其他诸如滚动和缩放之类的交互属于连续操作不属于FID指标的计算范围。

如果用户始终没有与您的网站进行交互怎么办？ 

一些用户的首次交互会处于不利的时间段内（当主线程长时间处于繁忙时），而另一些用户的首次交互会处于有利的时间段内（当主线程完全空闲时）。这意味着有些用户将没有 FID 值，有些用户的 FID 值较低，而有些用户的 FID 值可能较高。

FID 只测量事件处理过程中的"延迟"。FID 既不测量事件处理本身所花费的时间，也不测量浏览器在运行事件处理程序后更新用户界面所花费的时间。

开发者可以将事件处理程序逻辑封装在一个异步回调中（通过setTimeout()或requestAnimationFrame()），从而将逻辑与事件关联的任务分离。最终的结果虽然能够提升指标分数，但会使用户感知到的响应速度变慢。

```
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    const delay = entry.processingStart - entry.startTime;
    console.log('FID candidate:', delay, entry);
  }
}).observe({type: 'first-input', buffered: true});
```

指标和 API 之间的差异

* API 会为在后台选项卡中加载的页面分发first-input条目，但在计算 FID 时应忽略这些页面。
* 如果页面在首次输入发生前转移到后台，API 也会分发first-input条目，但在计算 FID 时仍应忽略这些页面（只有当页面始终处于前台时才考虑输入）。
* 当页面通过往返缓存恢复时，API 不会报告first-input条目，但在这些情况下应该测量 FID，因为这对用户来说是多次不同的页面访问体验。
* API 不会报告 iframe 中的输入，但要想正确测量 FID，您应该考虑这些输入。子框架可以使用 API 将这些输入的first-input条目报告给父框架来进行聚合。

[优化FID](https://web.dev/optimize-fid/)

* 减少第三方代码的影响
* 减少 JavaScript 执行时间
    * 分割长任务
    * 优化您的页面，做好交互准备
    * 使用 Web Worker
    * 减少 JavaScript 执行时间
* 最小化主线程工作
* 保持较低的请求数和较小的传输大小
  
## 可交互时间 TTI
[原文内容](https://web.dev/tti/)
TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。

先进行First Contentful Paint 首次内容绘制 (FCP)。
沿时间轴正向搜索时长至少为 5 秒的安静窗口，其中，安静窗口的定义为：没有长任务且不超过两个正在处理的网络 GET 请求。
沿时间轴反向搜索安静窗口之前的最后一个长任务，如果没有找到长任务，则在 FCP 步骤停止执行。
TTI 是安静窗口之前最后一个长任务的结束时间（如果没有找到长任务，则与 FCP 值相同）。

* 缩小 JavaScript
* 预连接到所需的来源
* 预加载关键请求
* 减少第三方代码的影响
* 最小化关键请求深度
* 减少 JavaScript 执行时间
* 最小化主线程工作
* 保持较低的请求数和较小的传输大小


## 总阻塞时间 TBT
总阻塞时间 (TBT) 指标测量First Contentful Paint 首次内容绘制 (FCP)与Time to Interactive 可交互时间 (TTI)之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。

优化点：

减少第三方代码的影响
减少 JavaScript 执行时间
最小化主线程工作
保持较低的请求数和较小的传输大小

### 累积布局偏移 CLS
[原文链接](https://web.dev/cls/)

```
let clsValue = 0;
let clsEntries = [];

let sessionValue = 0;
let sessionEntries = [];

new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    // 只将不带有最近用户输入标志的布局偏移计算在内。
    if (!entry.hadRecentInput) {
      const firstSessionEntry = sessionEntries[0];
      const lastSessionEntry = sessionEntries[sessionEntries.length - 1];

      // 如果条目与上一条目的相隔时间小于 1 秒且
      // 与会话中第一个条目的相隔时间小于 5 秒，那么将条目
      // 包含在当前会话中。否则，开始一个新会话。
      if (sessionValue &&
          entry.startTime - lastSessionEntry.startTime < 1000 &&
          entry.startTime - firstSessionEntry.startTime < 5000) {
        sessionValue += entry.value;
        sessionEntries.push(entry);
      } else {
        sessionValue = entry.value;
        sessionEntries = [entry];
      }

      // 如果当前会话值大于当前 CLS 值，
      // 那么更新 CLS 及其相关条目。
      if (sessionValue > clsValue) {
        clsValue = sessionValue;
        clsEntries = sessionEntries;

        // 将更新值（及其条目）记录在控制台中。
        console.log('CLS:', clsValue, clsEntries)
      }
    }
  }
}).observe({type: 'layout-shift', buffered: true});
```
### 与下一次绘画的交互 INP 
[原文链接](https://web.dev/inp/)

## 性能优化指标的计算
[老板让你做性能优化，第一步你应该做什么](https://juejin.cn/post/7121323745980973070)
[有道优化页面性能的手段](https://juejin.cn/post/7064405926035324964#heading-1)
[react官网的渲染优化](https://juejin.cn/post/7128369638794231839)
[React项目的性能优化](https://mp.weixin.qq.com/s/XSvhOF_N0VbuOKStwi0IYw)
* 在 HTML 内实现 Loading 态或者骨架屏；
* 去掉外联 css；
* 缓存基础框架；
* 使用动态 polyfill；
* 使用 SplitChunksPlugin 拆分公共代码；
* 正确地使用 Webpack 4.0 的 Tree Shaking；
* 使用动态 import，切分页面代码，减小首屏 JS 体积；
* 编译到 ES2015+，提高代码运行效率，减小体积；

使用 lazyload 和 placeholder 提升加载体验。
### 性能是相对的情况
1.设备不同：网速的问题
2.实现方式不同：加载速度一样，一个内容显示的比另一个快很多。，原因一个按需加载，另一个要等所有内容加载完了才显示
3.使用技术不同：两个图形化编辑网站，卡顿的是用dom实现的，一个是用canvas或者webGL实现的就更加流畅

### 规范指标
[原文链接](https://juejin.cn/post/6962742206692065287)
- **FCP（First Contentful Paint）首次内容绘制**
```
指浏览器从响应用户输入网络地址到页面内容的任何部分在屏幕上完成渲染的时间。这个就是实际有意义的首屏时间
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'first-contentful-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **FP白屏时间(首次渲染时间)**
```
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'first-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **LCP（Largest Contentful Paint）最大内容绘制**
表示可视区最大内容（文本块或图像元素）在屏幕上完成渲染的时间。该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录
```
const observer = new PerformanceObserver((list) => {
  let perfEntries = list.getEntries();
  let lastEntry = perfEntries[perfEntries.length - 1];
  // Process the latest candidate for largest contentful paint
});
observer.observe({entryTypes: ['largest-contentful-paint']});
if (window.performance) {
    let pf = window.performance;
    let pfEntries = pf.getEntriesByType('paint')
    let fp = pfEntries.find(each => each.name === 'largest-contentful-paint')
    console.log('first paint time: ', fp && fp.startTime)
}
```
- **TTI（Time to Interactive）可交互时间**
测量页面从开始加载到视觉上完成渲染、初始脚本完成加载，并能够快速、可靠地响应用户输入所需的可交互状态时间。 可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等）。
- **TBT（Total Blocking Time）总阻塞时间**
指 FCP(首次内容绘制) 与 TTI (可交互时间)之间的总时间。这期间，主线程被阻塞的时间过长，无法作出输入响应。任务的持续时间超过50毫秒。虽然在主线程上运行任务的总时间为 560 毫秒，但其中只有 345 毫秒被视为阻塞时间
- **CLS (Cumulative Layout Shift) 累积布局偏移**
累积布局偏移 (CLS) 是一个以用户为中心的测量视觉稳定性的重要指标，因为该项指标有助于量化用户发生意外布局偏移的频率，较低的 CLS 有助于用户的使用体验。解释一下就是想点取消，但因为别内容加载出来把按钮顶下去了，所以点成了确定订单。大写的尴尬。以前 CLS 测量的是整个页面生命周期内发生的所有单次布局偏移分数的总和。现在 CLS 测量的是整个页面生命周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。布局偏移：每当一个可见元素的位置从一个已渲染帧变更到下一个已渲染帧时，就发生了布局偏移。一连串的布局偏移：也叫会话窗口，是指一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。
最大的一连串：是指窗口内所有布局偏移累计分数最大的会话窗口。
- **FID（First input delay）首次输入延迟**
测量从用户第一次与您的网站交互（例如当他们单击链接、点按按钮或使用由JavaScript驱动的自定义控件）直到浏览器实际能够对交互做出响应所经过的时间。页面的 FID 应为100 毫秒或更短。
- **FPS 屏幕的刷新率为 60fps**
当页面元素动画、滚动或者渐变时绘制速率小于 60，就会不流畅，小于 24 就会卡顿，小于 12 基本认定卡爆了。1 帧的时长约 16ms，除去系统上下文切换开销，每一帧中只留给我们 10ms 左右的程序处理时间，如果一段脚本的处理时间超过 10ms，那么这一帧就可以被认定为丢失，如果处理时间超过 26ms，可以认定连续两帧丢失，依次类推。我们不能容忍页面中多次出现连续丢失五六帧的情况，也就是说必须想办法分拆执行时间超过 80ms 的代码程序，这个工作并不轻松。页面在刚开始载入的时候，需要初始化很多程序，也可能有大量耗时的 DOM 操作，所以前 1s 的必要操作会导致帧率很低，我们可以忽略。当然，这是对 PC 而言，Mobile 内容少，无论是 DOM 还是 JS 脚本量都远小于 PC，1s 可能就有点长了。
- **获取加载最慢的资源时间**
```
PerformanceObserver api监听资源的加载耗时，它返回的数据里面包含了几个重要的信息
name：资源URL；
initiatorType：资源类型，取值可能是css|img|xmlhttprequest等；
startTime：请求开始时间，高精度时间戳值，单位毫秒；
responseEnd：请求响应返回的时间，高精度时间戳值，单位毫秒；
duration：responseEnd于startTime的差值；

const pfObserver = new PerformanceObserver((list) => {
    const entries = list.getEntriesByType('resource');
    entries.forEach((item) => {
        // 各种资源的耗时
        // 首屏图片资源白名单：imgUrlWhiteList = []
        console.log(`${item.name: ${item.duration}}`);
    });
});
// 设定性能监听类别：资源
pfObserver.observe({ entryTypes: ['resource'] });
```
- **如何获取加载的图片资源**
对于img标签的图片资源，我们可以在MutationObserver或者IntersectionObserver监听器中直接操作dom读取img的src或者data-src属性，把图片URL保存起来；
针对背景图片，我们使用getComputedStyle方法获取节点的样式表，并取出其background-image的值；
- **First Meaningful Paint(FMP)**
FMP定义的是从页面开始加载到渲染出主要内容的过程，这个“主要内容”的定义依赖于各浏览器中的实现细节，因此它并没有作为一个标准化的指标。

- **首屏时间**

可以通过insertObserver实现异步监听dom和屏幕的相交值，如果满足就是首屏出现的时间。
1.如果首屏内容还在加载中，用户触发了页面滚动？
页面滚动之后，第二屏的内容就会出现在视窗，原本属于首屏的内容（部分内容可能并未完成渲染）却没在视窗中。那么，按照如上的统计方式，就会统计到当前处于视窗内容的渲染时间，这可能就是一个“误差”。我们需要一个共识：在首屏内容完全渲染之前页面触发了滚动，说明页面已经是一个可交互的状态，这种情况下，我们认为，用户触发滚动时那一帧的内容，已经是用户和开发者双方都能接受的首屏内容。基于这个前提，我们的处理方式是：
在页面滚动时，加一个锁，停止监听后续内容的变更，以初次滚动的时间点为时间界线，统计在此时间点前发出的（依据startTime）所有资源的请求耗时和dom树节点的渲染时间。

2.首屏内容是动态fetch的，甚至fetch的是图片资源。这种情况下只能保底统计到fetch请求的响应结束时间；
如果用户在响应之前触发了滚动，这时候数据渲染尚未开始，我们的程序无法捕捉到dom节点，那么也拿不到响应的图片资源，也就无法统计后续的渲染时间；如果用户是在数据返回之后，图片资源渲染之前触发的滚动，这种情况下由于能够捕捉dom树节点的渲染，理论上我们也能够获取响应图片资源的加载耗时；

### 每个指标的侧重点
- LCP 测量感知加载速度，并在页面的主要内容基本加载完成时，在页面加载时间轴中标记出相应的点；
- FID 测量响应度，并将用户首次尝试与页面交互的体验进行了量化；
- CLS 测量视觉稳定性，并对可见页面内容的意外布局偏移量进行了量化。

### 自定义性能指标
- 用户计时 API ：该规范定义了一个接口，以帮助 Web 开发人员通过访问高精度时间戳来衡量其应用程序的性能。
- 长任务 API ：该档定义了一个 API，网页作者可以使用该 API 来检测“长任务”的存在，这些任务会长时间垄断 UI 线程并阻止其他关键任务的执行
- 元素计时 API：本文档定义了一个 API，可以在屏幕上显示大型或开发人员指定的图像元素和文本节点时进行监控。
- 导航计时API：该规范定义了Web应用程序的接口，以访问用于导航文档的完整计时信息。
- 资源计时 API：该规范定义了Web应用程序的接口，以访问文档中资源的完整计时信息。
- 服务器计时：该规范使服务器能够将有关请求响应周期的性能指标传达给用户代理。它还标准化了JavaScript接口，以使应用程序能够收集和处理并对这些指标采取行动以优化应用程序交付。

### DOMContentLoaded
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。意思是HTML下载、解析完毕之后就触发。就算是async和defer的脚本也是在此之前执行
### load
页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。

## 网络层面

### DNS优化
1.在dns上做缓存减少dns查询时间

2.DNS 预解析加载 --- HTTP页面自动解析
在页面加载的过程当中，浏览器会自动将超链接 href 属性中的域名解析为 IP 地址
注意：为了确保安全性，HTTPS 页面中不允许自动解析

通过HTML标签方式
<meta http-equiv="x-dns-prefetch-control" content="on">
通过设置响应头的方式
ctx.set('X-DNS-Prefetch-Control', 'on')
说明：on 表示开启，off 表示关闭

3.手动解析（推荐）
<link rel="dns-prefetch" href="//file.cdn.com">
开启指定域名的预解析功能，多用于优化 CDN 资源，推荐在项目中使用。最佳使用位置如下
<meta charset="utf-8">
<link rel="dns-prefetch" href="//file.cdn.com">

4.域名收敛
就是将静态资源放在一个域名下。减少DNS解析的开销。

5.域名发散
是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。

6.多域名解析
一个域名对应多个IP，每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。将负载均衡的工作交给DNS，省去了网站管理维护负载均衡服务器的麻烦。

7.TTL缓存时间和异步请求。
每个DNS域名和IP在本地DNS服务器上都有TTL缓存时间。可以延长TTL缓存时间。

#### HTTPDNS
HTTPDNS使用HTTP与DNS服务器交互，代替传统的基于UDP的DNS协议，域名解析请求直接发送到HTTPDNS服务端，从而绕过运营商的Local DNS

HTTPDNS优点
```
1.防止域名劫持
由于 HttpDns 是通过 IP 直接请求 HTTP 获取服务器 A 记录地址，不存在向本地运营商询问 domain 解析过程，所以从根本避免了劫持问题。
2.精准调度
HTTPDNS能够直接获取到用户的IP地址，从而实现精确定位与导流
3.用户连接失败率下降
通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。
```
### 将静态资源放在CDN服务器上
什么是CDN CDN是如何做到快速返回数据的

CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。

### 建连复用：SSL化，SPDY建连高复用

SSL化，SSL化之后每个域名首次请求会额外增加一个“SSL握手”的时间，DNS建连也会比http的状态下要长，这是不可避免的，但是为什么一次完整的RequestRespone 流程耗时会比http状态下短呢？合理的解释是：SSL化之后，SPDY可以默认开启，SPDY协议下的传输效率和建连复用效益将最大化。SPDY协议下，资源并发请求数将不再受浏览器webview的并发请求数量限制，并发100+都是可能的
### 减少http请求，合并http请求
合并的原则

### 服务器端提供html和http静态资源时最好开启gzip

### http静态资源尽量用多个子域名,减少浏览器域名并发请求限制

### http缓存资源
给不经常变动的数据设置长的缓存时间。
### prefetch preLoad 区别 作用

preload 提前加载 当浏览器解析到这行代码就会去加载 href 中对应的资源但不执行，待到真正使用到的时候再执行

prefetch 预判加载 prefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源

当一个资源被 preload 或者 prefetch 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存极致（如 cache-control 或 max-age），它将被存储在 HTTP 缓存中可以被不同页面所使用。

正确使用 preload/prefetch 不会造成二次下载，也就说：当页面上使用到这个资源时候 preload 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本。

对于 preload 来说，一旦页面关闭了，它就会立即停止 preload 获取资源，而对于 prefetch 资源，即使页面关闭，prefetch 发起的请求仍会进行不会中断。

**这将会浪费用户的带宽吗？**

用 “preload” 和 “prefetch” 情况下，如果资源不能被缓存，那么都有可能浪费一部分带宽，在移动端请慎用。没有用到的 preload 资源在 Chrome 的 console 里会在 onload 事件 3s 后发生警告。原因是你可能为了改善性能使用 preload 来缓存一定的资源，但是如果没有用到，你就做了无用功。在手机上，这相当于浪费了用户的流量，所以明确你要 preload 对象。
**检测浏览器是否支持**
```
const preloadSupported = () => {
    const link = document.createElement('link');
    const relList = link.relList;
    if (!relList || !relList.supports)
        return false;
    return relList.supports('preload');
};
```

自己网站资源优先级也可以通过 Chrome 控制台 Network 一栏进行查看。对于使用 prefetch 获取资源，其优先级默认为最低，Lowest，可以认为当浏览器空闲的时候才会去获取的资源。
而对于 preload 获取资源，可以通过 "as" 或者 "type" 属性来标识他们请求资源的优先级（比如说 preload 使用 as="style" 属性将获得最高的优先级，即使资源不是样式文件)
### http2多路复用
### http2.0推送实现
preload和prefetch
### 开启keep-alive
在http1.1中默认开启了了Connection:keep-alive，它的作用是在下次发送请求时在一定时间内可以复用上一次的tcp链接而不需要重新建立这个链接
## 构建层面

### 资源加载优化的原则

```
1.第一个是关键资源个数。关键资源个数越多，首次页面的加载时间就会越长。
2.第二个是关键资源大小。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。
3.第三个是请求关键资源需要多少个 RTT（Round Trip Time）。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。
```
### 代码拆包打包优化

[具体的拆分包的操作过程](https://juejin.cn/post/6910893471339708429) 

1.将vendor中的第三方包尽量使用cdn链接的方式，利用externals的方式，首先将 CDN 引入的依赖加入到 externals 中。然后借助 html-webpack-plugin 将 CDN 文件打入 html。

利用webpack的splitchunks打包，将node_modules中的包打包到vendor中，但是有时候vendor会过大
其实可以使用第三方包的cdn链接，开启cdn加速，这样可以减少vendor包的大小，并且可以利用cdn加速

如果如果我们想引用一个库，但是又不想让 webpack 打包，并且又不影响我们在程序中以 import、require 或者 window/global 全局等方式进行使用，那就可以通过配置 externals

externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。相反，所创建的 bundle 依赖于那些存在于用户环境(consumer's environment)中的依赖。

减少不必要的js文件加载

关闭sourceMap
```
sourcemap是为了方便线上调试用的，因为线上代码都是压缩过的，导致调试极为不便，而有了sourcemap，就等于加了个索引字典，出了问题可以定位到源代码的位置。
但是，这个玩意是每个js都带一个sourcemap，有时sourcemap会很大，拖累了整个项目加载速度，为了节省加载时间，我们将其关闭掉。
vue.config.js配置
productionSourceMap: false, //取消.map文件产生

```
不打包库文件

```
chainWebpack: config => {
      // 在这里设置 需要cdn的依赖和插件
      config.set('externals', {
        'vue': 'Vue',
        'vue-router': 'VueRouter',
        'axios': "axios",
        'moment': "moment",
      });
      //这是一个方法,对config进行了操作之后必须要return出来
      return config
    },
```
在public/index.html的head标签中可以引入如下的cdn地址:

```
<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/vue-router/3.2.0/vue-router.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
```
2.拆vendor如果第三方包没有提供cdn链接，那么就分开拆成多个包在不同页面引入即可。将首页需要的包和其他页面需要的包拆分打包。
[配置打包例子图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42584ebdea5b4a4faa4ea3e1b9c29a01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

3.动态引入

```
比如有些包是用户点击操作之后才需要加载的，例如路由跳转，可以改成动
```
态引入的方式import 打包成一个分包

4.不打包某些第三方包的部分文件

```
// webpack plugins
plugins: [
  // Ignore all locale files of moment.js
  new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),
]
```
5.可以按需加载的第三方包 按需加载

### React.lazy 和 suspense 结合 懒加载组件

```
const MonacoEditor = React.lazy(() => import('react-monaco-editor'));

<suspense fallback={<div>loading....</div>}>
    <MonacoEditor/>
</suspense>
```
### vue的路由懒加载

1.对于首屏的资源，将首要渲染资源和不是首要渲染资源。使用webpack的三种分包策略分开打包实现资源按需加载。比如路由懒加载，按照如下写法(vue利用webpack的动态引入模块的方法将不同的路由页面打包成不同的chunk实现按需加载)。但实际上我们会发现加载首页代码的之后没有点击跳转路由也会加载单独打包出来的几个页面代码是因为，vue还利用了webpack的preload和prefetch

prefetch: 一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。
preload：用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload

(webpack4.6.0以上支持prefetching 特性)

路由页面的代码属于prefetch资源，这些文件的加载不会影响到当前页面的打开，可以降低页面跳转的等待时间。

那可以关闭/禁用prefetch吗?」 答案是「可以」 
Prefetch 将会消耗带宽/流量。如果你的应用很大且有很多 async chunk，而用户主要使用的是对流量较敏感的移动端，那么你可能需要关掉 prefetch 并手动选择要提前获取的代码区块.

```
// vue.config.js
module.exports = {
  chainWebpack: config => {
    // 移除 prefetch 插件
    config.plugins.delete('prefetch')
    // 或者,  修改它的选项：
    config.plugin('prefetch').tap(options => {
      options[0].fileBlacklist = options[0].fileBlacklist || []
      options[0].fileBlacklist.push(/myasyncRoute(.)+?\.js$/)
      return options
    })
  }
}
```
那怎么手动选择要预读取的文件呢?

```
import(/* webpackPrefetch: true */ './someAsyncComponent.vue')
```

```
  {
    path: '/manageGroup/add',
    name: 'ManageAddGroup',
    component: () => import(/* webpackChunkName: "manageGroupAdd" */ '/views/Personal/ZGMP/AddGroup/index.vue'),
  },
  {
    path: '/privateChat/list',
    name: 'PrivateChat',
    component: () => import(/* webpackChunkName: "privateChat" */ '/views/Personal/PrivateChat/index.vue'),
  },
  {
    path: '/privateChat/add',
    name: 'PrivateChat',
    component: () => import(/* webpackChunkName: "privateChat" */ '/views/Personal/PrivateChat/add.vue'),
  },
```

### 压缩js代码
```
npm i --save-dev compression-webpack-plugin

vue.config.js配置插件
const CompressionWebpackPlugin = require('compression-webpack-plugin');
const productionGzipExtensions = ['js', 'css'];
module.exports = {
  configureWebpack: {
        plugins: [
          new CompressionWebpackPlugin({
            algorithm: 'gzip',
            test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
            threshold: 10240,
            minRatio: 0.8
          }), 
        ],
    },
}
```
## 服务端层面

1.服务端渲染SSR

TODO 同构等问题 待补充。。。

2.服务端开启gzip压缩


## 浏览器渲染层面

页面缓存(例如 vue 的 keep-alive)

模块资源缓存(缓存页面核心模块数据)

模块按需加载(拆分打包，分别请求)

数据请求优化(核心数据和营销不重要数据分开请求)

监控检测(收敛图片、资源加载失败的问题)


### 页面构建流程
[原文链接](https://juejin.cn/post/7017807404645482504)
1.js外联文件放到body底部，css外联文件放到head内

- js执行浏览器会被js引擎"霸占"，从而导致渲染进程无法执行阻塞DomTree的渲染的
- css加载并不会阻塞Dom Tree的构建
- css加载会阻塞Dom Tree的渲染，也就是Render Tree的生成
- 位于css代码之前的js代码加载执行是毫无疑问的，但位于css加载之后的代码，css代码的加载是会阻塞后续js代码的执行的。
- HTML和Css的加载其实他们是并行加载，这也就印证了我们上边提到的css加载并不会影响Dom Tree的构建。
- 同时浏览器的渲染引擎和js的解释引擎他们是互斥的，也就是说css加载和dom加载都会和js执行加载互斥的。(当然排除scirpt标签上的defer和async)属性。
- 关于第二点，css的加载并不会阻塞Dom Tree的构建，但是如果在css文件之后存在js脚本，js是会阻塞dom tree的构建的，因为css加载阻塞了js执行，所以间接的阻塞了dom tree的构建。
- css的加载是会阻塞后续js的执行的，后续js会等待css加载完成后才会执行。
- css的加载并不会阻塞Dom Tree的构建。
- css的加载是会阻塞页面渲染的，因为页面渲染的Render Tree是需要css om和dom tree进行合并从而渲染页面的。

[渲染构建流程图](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33869c017bd4525a25632ef61fcbee4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

#### 因为构建流程可能产生的问题

当我们的js加载快于css加载13ms完成。当js加载完成后css还在请求download中，此时由于dom Tree已经构建完毕符合我们js的执行时机,所以此时js优先于css执行完成。当我们执行js时页面上并不存在任何样式，此时我们通过getBoundingClientRect获取的值自然是不正确的。由于defer脚本已经完成，所以在css加载过程中其实线程是空虚的，所以此时js引擎会执行加载完成的defer脚本进行执行。造成js提前与css执行完毕。

所以会存在在useEffect中获取dom元素的位置会导致位置是随机值，解决办法就是用window.onload中获取位置。

### 脚本执行顺序和放置顺序以及脚本的push和preload prefetch
[原文链接](https://zhuanlan.zhihu.com/p/48521680)
并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。

#### async
* async 的设置，会使 script 脚本异步加载并**在允许的情况下执行**。
* 换句话说， async的执行，并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁先执行。
* async 舍弃了 script脚本之间的依赖关系。而是谁先加载完谁先执行。

#### defer
* defer 的设置，会使 script 脚本异步加载；
* 如果有多个 defer属性的script 标签存在，则会按照**顺序执行** 所有script
* defer 脚本会在**文档渲染完后，DOMContentLoaded之前**执行。
* 使用 defer 属性在加载脚本的时候不阻塞 HTML 的解析，defer 加载脚本执行会在所有元素解析完成，DOMContentLoaded 事件触发之前完成执行。它的用途其实跟 preload 十分相似。你可以使用 defer 加载脚本在 head 末尾，这比将脚本放在 body 底部效果来的更好。它相比于 preload 加载的优势在于浏览器兼容性好，从 caniuse 上看基本上所有浏览器都支持，覆盖率达到 93%，不足之处在于：defer 只作用于脚本文件，对于样式、图片等资源就无能为力了，并且 defer 加载的资源是要执行的，而 preload 只下载资源并不执行，待真正使用到才会执行文件。对于页面上主/首屏脚本，可以直接使用 defer 加载，而对于非首屏脚本/其它资源，可以采用 preload/prefeth 来进行加载。

#### async/defer对window.onload的影响

使用defer的script标签，会在window.onload 事件之前被执行

使用async的script标签，对window.onload 事件没有影响，window.onload可以在之前或之后执行
### HTTP/2 Server Push
HTTP/2 PUSH 功能可以让服务器在没有相应的请求情况下预先将资源推送到客户端。这个跟 preload/prefetch 预加载资源的思路类似，将下载和资源实际执行分离的方法，当脚本真正想要请求文件的时候，发现脚本就存在缓存中，就不需要去请求网络了。我们假设浏览器正在加载一个页面，页面中有个 CSS 文件，CSS 文件又引用一个字体库，对于这样的场景。如果加了push就是会在客户端请求html的时候服务端返回字体文件。而对于 preload，服务端就不会主动地推送字体文件，在浏览器获取到页面之后发现 preload 字体才会去获取。

#### 使用案例
- 提前加载字体文件。由于字体文件必须等到 CSSOM 构建完成并且作用到页面元素了才会开始加载，会导致页面字体样式闪动。所以要用 preload 显式告诉浏览器提前加载。假如字体文件在 CSS 生效之前下载完成，则可以完全消灭页面闪动效果。
- 使用 preload 预加载第二屏的内容，在网页开发中，对于非首屏部分采用懒加载是我们页面常用的优化手段，所以我们在页面 onload 之后可以通过 preload 来加载次屏所需要的资源，在用户浏览完首屏内容滚动时能够更快地看到次屏的内容。
- 在页面加载完成之后，可以分析页面上所有的链接，判断用户可能会点击的页面，分析提取下一跳页面上所有的资源使用 prefetch 进行加载(这里不使用 preload，因为不一定会点击)，浏览器会在空闲地时候进行加载，当用户点击链接命中了缓存，这可以有效地提升下一页面的首屏渲染时间。
- 对于商品列表页面，在用户鼠标停留在某个商品的时候，可以去分析商品详情页所需要的资源并提前开启 preload 加载，跟第 3 点类似，都是用来预测用户的行为并且做出一些预加载的手段，区别在于当用户停留在商品上时，点击命中率更高，preload 可以立即加载资源，有效提升缓存命中率。
# 渲染优化

1.减少DOM的数量和嵌套层级
2.图片加载优化
3.减少重绘重排
4.减少dom操作,减少读取几何布局属性
5.class代替style，
6.resize，scroll时节流防抖
7.css3开启GPU加速
8.css优化：减少选择器
9.使用骨架屏
10.不将复杂对象放到响应式对象中，使用Object.freeze
11.使用时间分片api处理长任务(耗时超过50ms的任务)
12.不要一条一条地修改DOM的样式。还不如预先定义好css的class，然后修改DOM的className
13.把DOM离线后修改。如： 使用documentFragment 对象在内存里操作DOM
14.先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来
15.clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下

减少回流/重绘

重绘：页面中元素样式的改变并不影响它在文档流中的位置时（如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并 重新绘制
回流：当 Render Tree 中部分或全部元素的 尺寸、结构、某些属性 发生改变时，浏览器 重新渲染 部分或全部文档

减少对 DOM 进行频繁操作

使经常变动的元素脱离文档流，如具有持续性的动画效果，会一直触发回流和重绘
避免访问或减少访问会导致浏览器强制刷新队列的属性，如：offsetTop、offsetLeft、offsetWidth等

【扩展】浏览器的渲染队列机制会通过 队列 将会触发 回流或重绘 的操作进行存储，等到一定的时间或一定的数量时再执行这些操作
避免对 css 进行单个修改，如在 JavaScript 修改多个样式时，尽量使用 css 选择器

实现样式的集中变更

使用 will-change 开启 GPU 加速，will-change 指定的属性使得浏览器可在元素属性真正发生变化之前提前做好对应的优化
预先设定图片尺寸，避免图片资源加载完成后引发回流

防抖/节流

防抖：多次频繁触发执行操作，以 最后一次 为准，忽略中间过程
节流：在指定的时间间隔内，只允许 执行一次对应的操作
合理使用 防抖/节流 优化应用中的操作，比如 节流 可用于优化 滚动事件、模糊搜索等，防抖 可用于优化一些按钮点击操作等。

Web Worker

JavaScript 是单线程的，如果存在需要大量计算的场景（如视频解码），UI 线程就会被阻塞，甚至浏览器直接卡死。
Web Worker 可以使脚本运行在新的线程中，它们独立于主线程，可以进行大量的计算活动，而不会影响主线程的 UI 渲染，但不能滥用 Web Worker 。

虚拟列表

最常用的还是 分页加载 的方式

基于 table 表格的渲染，只会渲染固定数量的 DOM
基于 上拉加载 列表的渲染，随着加载数据的增多，对应的 DOM 节点也会增多，达到某个限制页面一定会发生卡顿
虚拟列表 核心就是固定渲染的 DOM 数，通过动态切换数据内容实现视图的更新，并保证文档中真实 DOM 的数量不随着数据量增大而增大（其实和 table 分页很像，但它支持滚动）。


## 浏览器中的进程

- 浏览器进程
- 插件进程
- GPU进程
- 网络进程
- 渲染进程（GUI渲染线程、JS引擎线程、事件触发线程）


```
浏览器进程: 你可以理解浏览器进程为一个统一的"调度大师"去调度其他进程，比如我们在地址栏输入url时，浏览器进程首先会调用网络进程。 它可以做一些子进程管理以及一些存储的处理。


渲染进程: 这个进程对于我们来说是最重要的一个进程，每一个tab页都拥有独立的渲染进程，它的主要作用是渲染页面。


网络进程: 这个进程是控制对于一些静态资源的请求，它将资源请求完成之后会交给渲染进程进行渲染。


GPU进程: 这个进程可以调用硬件进行渲染，从而实现渲染加速。比如translate3d等css3属性会骗取调用GPU进程从而开启硬件加速。


插件进程: chrome中的插件也是一个独立的进程。

```
### 页面渲染进程

```
1.浏览器通过请求得到一个 HTML文本
2.渲染进程解析 HTML 文本，构建 DOM 树
3.浏览器解析 HTML 的同时，如果遇到内联样式或者样本样式，则下载并构建样式规则（stytle rules）。若遇到 Javascript 脚本，则会下载并执行脚本
4.DOM 树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）
5.渲染进程开始对渲染树进行布局，生成布局树（layout tree）
6.渲染进程对布局树进行绘制，生成绘制记录
7.渲染进程对布局树进行分层，分别栅格化每一层并得到合成帧
8.渲染进程将合成帧发送给 GPU 进程将图像绘制到页面中


* 构建 DOM 树 --- 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
* 样式计算 --- 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
* 布局阶段 --- 创建布局树，并计算元素的布局信息。排除 display: none 的节点，计算元素的位置信息，确定元素的位置，构建一棵只包含可见元素布局树。
* 分层 --- 对布局树进行分层，并生成分层树。对拥有层叠上下文属性的元素，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。
* 栅格化 --- 合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图(实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图)。
* 显示 --- 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

```

## 图片加载优化

异步队列分批加载图片
intersectionObserver加载图片
### 图片加载失败重新加载组件
```
<common-image
          class="main-card-swiper-image"
          src="{{item.image}}"
          openImageRetry="{{index < 2}}"
          imageAnalysis="{{ {open: index < 2, tag: 'home_main_card'} }}"
        ></common-image>
```

```
<template>
  <image
    wx:if="{{src}}"
    src="{{url || src}}"
    mode="{{mode}}"
    webp="{{webp}}"
    lazy-load="{{lazyLoad}}"
    show-menu-by-longpress = "{{showMenuByLongPress}}"
    binderror="errHandler"
    bindload="loadHander"
    class="img-preload-wrap"
  />
</template>

<script>
  import { createComponent } from '@mpxjs/core'
  const Omega = getApp().Omega

  createComponent({
    data: {
      url: '',
      requestCount: 0,
      isTry: 0 // 0 不重新请求  1 重新请求
    },
    properties: {
      src: {
        type: String,
        value: ''
      },
      mode: {
        type: String,
        value: 'scaleToFill'
      },
      webp: {
        type: Boolean,
        value: false
      },
      lazyLoad: {
        type: Boolean,
        value: false
      },
      showMenuByLongPress: {
        type: Boolean,
        value: false
      },
      // 以下额外添加的一些功能
      // 是否开启图片加载率分析上报
      imageAnalysis: {
        type: Object,
        value: {
          open: false, // 是否开启图片分析，每次分析都会上报一套omega埋点，请勿批量添加
          tag: '' // 类型标识，会用于分析image的时候
        }
      },
      // 开启在图片加载失败的时候进行一次自动重试操作
      openImageRetry: {
        type: Boolean,
        value: false
      }
    },
    watch: {
      src: {
        handler(val, oldval) {
          if (val && this.imageAnalysis?.open) {
            // 图片链接请求更改，重置状态
            if (oldval) {
              this.url = ''
              this.isTry = 0
              this.requestCount = 0
            }
            this.sendOmegaLog('get')
          }
        },
        immediate: true
      }
    },
    detached() {
      (!this.requestCount && this.src) && this.sendOmegaLog('unload')
    },
    methods: {
      sendOmegaLog(type, e = {}) {
        if (this.imageAnalysis?.open) {
          const maps = {
            get: 'tech_mini_image_data_sw', // 拉取数据
            err: 'tech_mini_image_error_sw', // 图片加载失败
            load: 'tech_mini_image_load_sw', // 加载图片成功
            unload: 'tech_mini_image_unload_sw' // 未执行err和load事件时，触发
          }
          Omega.trackEvent(maps[type], {
            image_src: this.url || this.src,
            tag: this.imageAnalysis?.tag,
            err_msg: e?.detail?.errMsg,
            is_try: this.isTry
          })
        }
      },
      errHandler(e) {
        this.requestCount++
        this.sendOmegaLog('err', e)
        const triggerName = this.isTry ? 'retryError' : 'error'
        this.triggerEvent(triggerName, {
          err: e,
          is_try: this.isTry
        })

        // 请求重试
        if (this.openImageRetry) {
          this.isTry = 1
          this.openImageRetry = false
          this.url = this.src + '?timestamp=' + Date.now()
          this.sendOmegaLog('get')
        }
      },
      loadHander(event) {
        this.requestCount++
        this.triggerEvent('load', event)
        this.sendOmegaLog('load')
      }
    }

  })
</script>

<style lang="stylus" scoped>
  .img-preload-wrap
    height 100%
    width 100%
</style>

```
### webp压缩格式

[原文链接](https://juejin.cn/post/7039564188385017864)

WebP 是一种同时提供了有损压缩与无损压缩的图片文件格式。可以大大压缩图片的大小，并且图片的质量和 png、jpeg 等相同。WebP 的无损压缩比 png 格式的文件平均少了 45％ 的大小。

目前大约 95.77% 的浏览器都支持 WebP 格式的图片

判断浏览器是否支持 webp 格式的图片
支持，展示 webp 格式的图片
不支持，使用图片原始格式进行展示

第一种js方式
```
   /** 
   * 判断浏览器是否支持 webp
   */
   // 方法1: 通过尝试加载一张 webp 格式的图片来判断
   function isSupportWebp(callback) {
       const imgUrl = 'https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75_.webp';
       const image = new Image();
       image.src = imgUrl;
       image.onload = function() {
           // 加载成功，说明支持 webp，在回调函数中
           callback(true);
       }
       image.onerror = function() {
           // 加载失败，说明不支持 webp
           callback(false);
       }
   }
   /** 
   * 选择浏览器支持的图片格式
   */
   function loadImg(imgElement, compressedImg, originalImg) {
       isSupportWebp((isSupport) => {
           imgElement.src = isSupport ? compressedImg : originalImg;
       })
   }

   // 方法2: 通过判断 HTMLCanvasElement.toDataURL() 返回的 dataURI 来判断
   function isSupportWebp() {
       const str = document.createElement('canvas').toDataURL('image/webp');
       // 如果支持则会返回传入的类型 image/webp --> data:image/webp;base64,UklGRtgCAABXRUJQVlA4WAoAAAAwAAAAKwEAlQAASUNDUBgCAAAAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAABZAAAABRnWFlaAAABeAAAABRiWFlaAAABjAAAABRyVFJDAAABoAAAAChnVFJDAAABoAAAAChiVFJDAAABoAAAACh3dHB0AAAByAAAABRjcHJ0AAAB3AAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAFgAAAAcAHMAUgBHAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z3BhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABYWVogAAAAAAAA9tYAAQAAAADTLW1sdWMAAAAAAAAAAQAAAAxlblVTAAAAIAAAABwARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAMgAwADEANkFMUEgSAAAAAQcQEREQkCT+/x9F9D/tf0MAVlA4IIAAAABwDQCdASosAZYAPm02mUmkIyKhICgAgA2JaW7hdrEbQAnsA99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfasAAD+/9YAAAAAAAAAAA==
       // 如果不支持则会返回默认值 image/png --> data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII
       return str.indexOf('image/webp') > -1;
   }

   /** 
   * 选择浏览器支持的图片格式
   */
   function getImg(compressedImg, originalImg) {
       const isSupport = isSupportWebp();
       return isSupport ? compressedImg : originalImg;
   }
```
第二种 html方式


```
HTML 处理：<picture> 元素

  利用浏览器会选择 <picture> 元素中最匹配的子 <source> 元素，如果没有匹配的，就选择 <img> 元素的 src 属性中的 URL 这一特点。如果浏览器支持 image/webp 类型的图片，则加载 <source> 元素中 srcset 属性指向的资源，如果不支持则跳过 <source> 元素，加载 <img> 元素。

<picture>
    <source type="image/webp" srcset="https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75_.webp" />
    <img src="https://img.alicdn.com/imgextra/i2/O1CN01uvFm6B1XMMrTkObKV_!!6000000002909-0-tps-520-280.jpg_q75.jpg"> 
</picture>

```

## 时间分片处理耗时操作
requestIdleCallback 的定位是处理不重要且不紧急的任务。requestIdleCallback 不是每一帧结束都会执行，只有在一帧的 16.6ms 中渲染任务结束且还有剩余时间，才会执行。兼容性问题不能使用。根据react文档自己实现

requestIdleCallback 是一个兼容性不那么好的功能，所以我们使用前得判断它是否支持
我们可以使用 window.requestIdleCallback() 方法来插入一个函数，这个函数将在浏览器空闲时被调用；requestIdleCallback
 它的参数为 callback 和 可选的 timeout；如果指定了 timeout 且为正值；则回调在 timeout 毫秒后还没调用时，回调任务就会被放入事件循环里排队，这样做可能会影响性能；


注意点：因为它发生在一帧的最后，此时页面布局已经完成，所以不建议在 requestIdleCallback 里再操作 DOM，这样会导致页面再次重绘。


思路

```
1.使用 requestAnimationFrame 获取渲染某一帧的开始时间，进而计算出当前帧到期时间点；
2.使用 performance.now() 实现微秒级高精度时间戳，用于计算当前帧剩余时间；
3.使用 MessageChannel 零延迟宏任务实现任务调度，如使用 setTimeout() 则有一个最小的时间阈值，一般是 4ms；

```
具体实现
```
// 当前帧到期时间点
let deadlineTime;
// 回调任务
let callback;
// 使用宏任务进行任务调度
const channel = new MessageChannel();
const port1 = channel.port1;
const port2 = channel.port2;
// 接收并执行宏任务
port2.onmessage = () => {
  // 判断当前帧是否还有空闲，即返回的是剩下的时间
  const timeRemaining = () => deadlineTime - performance.now();
  const _timeRemain = timeRemaining();
  // 有空闲时间 且 有回调任务
  if (_timeRemain > 0 && callback) {
    const deadline = {
      timeRemaining,
      didTimeout: _timeRemain < 0,
    };
    // 执行回调
    callback(deadline);
  }
};
window.requestIdleCallback = function (cb) {
  requestAnimationFrame((rafTime) => {
    // 结束时间点 = 开始时间点 + 一帧用时16.667ms
    deadlineTime = rafTime + 16.667;
    // 保存任务
    callback = cb;
    // 发送个宏任务
    port1.postMessage(null);
  });
};
```
# 如果页面卡顿，你觉得可能是什么原因造成的？有什么办法锁定原因并解决吗？

* 是否是网络请求太多，导致数据返回较慢，可以适当做一些缓存
* 可能是某块资源的bundle太大，可以考虑拆分一下
* 然后排查一下js代码，是不是某处有过多循环导致占用主线程时间过长
* 浏览器某帧渲染的东西太多，导致的卡顿
* 在页面渲染过程中，可能有很多重复的重排重绘
* 内存泄漏导致浏览器gc时间太长

# 实际小程序开发性能遇到的问题
1.首开时间长，首屏引入组件过多，js加载时间长，将不主要的组件放到异步分包中加载。同时整理营销公共组件到不同分包中可以减少营销组件多次打包造成包体积冗余的问题。

2.首屏运营资源位过多，改造接口将准星运营配置数据接口一次性请求所有首页资源位数据。拆分接口将关键模块接口和营销接口数据拆分成两个接口返回数据。

3.图片加载过多，雪碧图和加载图片失败重试。

4.关键模块优先，首页主要接口先请求。其他接口次之。

# 浏览器渲染1帧的过程中发生了什么

下面来看完整的一帧中，具体做了哪些事情:
1）首先需要处理输入事件，能够让用户得到最早的反馈
2）接下来是处理定时器，需要检查定时器是否到时间，并执行对应的回调
3）接下来处理 Begin Frame（开始帧），即每一帧的事件，包括 window.resize、scroll、media query change 等
4）接下来执行请求动画帧 requestAnimationFrame（rAF），即在每次绘制之前，会执行 rAF 回调
5）紧接着进行 Layout 操作，包括计算布局和更新布局，即这个元素的样式是怎样的，它应该在页面如何展示
6）接着进行 Paint 操作，得到树中每个节点的尺寸与位置等信息，浏览器针对每个元素进行内容填充
7）到这时以上的六个阶段都已经完成了，接下来处于空闲阶段执行requestIdleCallback




